{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/volumes/volumes-orchestrator.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/volumes/volumes-orchestrator.service.js","mtime":1539717142391},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["/**\n *  Cloud Volumes list Orchestrator. Heal the world we live in, save it for our children\n *  ====================================================================================\n *\n *  =README=\n *  This orchestrator is used to init and manage a Cloud Volumes list.\n */\nangular.module('managerApp').service('CloudProjectComputeVolumesOrchestrator', [\"$q\", \"$translate\", \"$rootScope\", \"$timeout\", \"CLOUD_INSTANCE_DEFAULTS\", \"Poller\", \"CloudUserPref\", \"OvhApiCloudProjectVolume\", \"OvhApiCloudProjectVolumeSnapshot\", \"CloudProjectComputeVolumesFactory\", \"OvhApiCloudProjectRegion\", \"Toast\", function ($q, $translate, $rootScope, $timeout, CLOUD_INSTANCE_DEFAULTS, Poller, CloudUserPref, OvhApiCloudProjectVolume, OvhApiCloudProjectVolumeSnapshot, CloudProjectComputeVolumesFactory, OvhApiCloudProjectRegion, Toast) {\n  // Warning: all values must be reset at init (see resetDatas())\n  var self = this;\n  var editedVolume;\n  var paramEdition = null; // enum NAME, SIZE\n\n  var currentVolumesMovePending;\n\n  var resetDatas = function resetDatas() {\n    // The full volumes list to display\n    self.volumes = null; // Project type (existing, template, template-new)\n\n    self.serviceType = null; // Current edited volume\n\n    editedVolume = null; // Current moving volumes IDs\n    // @todo: to reset when switching project\n\n    currentVolumesMovePending = []; // Stop polling if launched\n\n    self.killPollVolumes();\n  };\n  /**\n   *  Get the default volume configuration options for a specified region\n   */\n\n\n  function getDefaultVolumeConfigurationForRegion(defaultRegion) {\n    var options = {\n      name: $translate.instant('cpci_volume_default_name'),\n      region: defaultRegion,\n      size: 100,\n      type: 'classic',\n      bootable: false\n    };\n    var optionsQueue = []; // @todo: enums toussa\n\n    return $q.allSettled(optionsQueue).then(function () {\n      if (_.keys(self.volumes.volumes).length > 0) {\n        // use the most recent volume parameters\n        var mostRecentVolume = _.last(_.sortBy(_.flatten(_.values(self.volumes.volumes)), 'creationDate'));\n\n        if (mostRecentVolume) {\n          options.region = mostRecentVolume.region;\n          options.size = mostRecentVolume.size;\n          options.type = mostRecentVolume.type;\n        }\n      }\n\n      return options;\n    }, function () {\n      return options;\n    });\n  }\n  /**\n   *  Get the default volume configuration options\n   */\n\n\n  var getDefaultVolumeConfiguration = function getDefaultVolumeConfiguration() {\n    return OvhApiCloudProjectRegion.v6().query({\n      serviceName: self.volumes.serviceName\n    }).$promise.then(function (regionList) {\n      // check if the default region exists\n      var region = CLOUD_INSTANCE_DEFAULTS.region;\n\n      if (_.indexOf(regionList, region) === -1) {\n        region = _.first(regionList);\n      }\n\n      return getDefaultVolumeConfigurationForRegion(region);\n    });\n  };\n  /**\n   *  Add a volume into project Volumes list\n   */\n\n\n  this.addNewVolumeToList = function (targetId) {\n    var volume;\n    return $q.when(true).then(function () {\n      return getDefaultVolumeConfiguration();\n    }).then(function (options) {\n      volume = self.volumes.addVolumeToList(options, targetId);\n      volume.status = 'DRAFT';\n      self.saveToUserPref();\n      return volume;\n    });\n  };\n  /**\n   * Add a volume from a given snapshot into project Volumes list\n   */\n\n\n  this.addNewVolumeFromSnapshotToList = function (targetId, snapshot) {\n    var getVolumeFromSnapshot = function getVolumeFromSnapshot(snapshot) {\n      // eslint-disable-line\n      if (!snapshot || !snapshot.id) {\n        return $q.reject({\n          data: {\n            message: 'Snapshot id cannot be found'\n          }\n        });\n      }\n\n      return OvhApiCloudProjectVolume.v6().get({\n        serviceName: self.volumes.serviceName,\n        volumeId: snapshot.volumeId\n      }).$promise;\n    };\n    /**\n     * Since snapshot doesnt contains the volume type we need to fetch the volume.\n     * If the volume has been deleted the api still has a backup of it so it's not a problem.\n     */\n\n\n    return getVolumeFromSnapshot(snapshot).then(function (toRestore) {\n      if (!toRestore || !toRestore.type) {\n        return $q.reject({\n          data: {\n            message: 'Volume to restore cannot be found'\n          }\n        });\n      }\n\n      var options = {\n        name: snapshot.name || toRestore.name,\n        region: snapshot.region || toRestore.region,\n        size: snapshot.minDisk || toRestore.size,\n        type: toRestore.type,\n        bootable: toRestore.bootable,\n        snapshot: snapshot\n      };\n      var volume = self.volumes.addVolumeToList(options, targetId);\n      volume.status = 'DRAFT';\n      self.saveToUserPref();\n      return $q.when(volume);\n    });\n  };\n  /**\n   *  Launch the volume creation.\n   */\n\n\n  this.saveNewVolume = function (volume) {\n    return volume.create().then(function () {\n      self.saveToUserPref();\n      self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   *  Set the volume that is currently in edition\n   */\n\n\n  this.turnOnVolumeEdition = function (volume) {\n    editedVolume = volume;\n    editedVolume.startEdition();\n  };\n  /**\n   *  Close/Reset the volume that is currently in edition\n   */\n\n\n  this.turnOffVolumeEdition = function (reset) {\n    editedVolume.stopEdition(!!reset);\n    delete editedVolume.snapshot; // in case of snapshot restore, we delete snapshot reference\n\n    editedVolume = null;\n  };\n  /**\n   *  Get the volume that is currently in edition\n   */\n\n\n  this.getEditedVolume = function () {\n    return editedVolume;\n  };\n  /**\n   *  Get parameters for current edition\n   */\n\n\n  this.getEditVolumeParam = function () {\n    return paramEdition;\n  };\n  /**\n   *  Get parameters for current edition\n   */\n\n\n  this.setEditVolumeParam = function (param) {\n    paramEdition = param;\n  };\n  /**\n   *  Save the volume modifications\n   */\n\n\n  this.saveEditedVolume = function (volume) {\n    return volume.edit().then(function () {\n      self.saveToUserPref();\n      self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n       *  Delete volume\n       */\n\n\n  this.deleteVolume = function (volumeOrVolumeId) {\n    var volume = typeof volumeOrVolumeId === 'string' || typeof volumeOrVolumeId === 'number' ? self.volumes.getVolumeById(volumeOrVolumeId) : null;\n\n    if (!volume) {\n      return $q.reject({\n        data: {\n          message: 'Volume id cannot be find'\n        }\n      });\n    }\n\n    if (volume.status === 'DRAFT') {\n      return $q.when(true).then(function () {\n        self.volumes.removeVolumeFromList(volume);\n        self.saveToUserPref();\n      });\n    }\n\n    return volume.remove().then(function () {\n      self.saveToUserPref();\n      self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n       *  Move a volume.\n       *  If targetId: move it to a vm, if not: move it to \"parking\"\n       */\n\n\n  this.moveVolume = function (volumeOrVolumeId, targetId) {\n    var volume = typeof volumeOrVolumeId === 'string' || typeof volumeOrVolumeId === 'number' ? self.volumes.getVolumeById(volumeOrVolumeId) : null;\n    targetId = targetId || 'unlinked'; // eslint-disable-line\n\n    if (!volume) {\n      return $q.reject({\n        data: {\n          message: 'Volume id cannot be find'\n        }\n      });\n    }\n\n    var sourceId = volume.attachedTo && volume.attachedTo.length ? volume.attachedTo[0] : 'unlinked';\n    var action = !targetId || targetId === 'unlinked' ? 'detach' : 'attach';\n\n    if (volume.status === 'DRAFT') {\n      // @todo\n      return $q.when('TODO').then(function () {\n        self.saveToUserPref();\n      });\n    } // We need to hide it from previous location,\n    // and show it into its new location BEFORE the end of the task...\n    // To do that, we move it, and we put a special status.\n\n\n    self.volumes.removeVolumeFromList(volume, sourceId);\n    self.volumes.addVolumeToList(volume, targetId);\n    currentVolumesMovePending.push(volume.id);\n    volume.status = \"\".concat(action, \"ing\");\n    return volume[action](action === 'detach' ? sourceId : targetId).then(function () {\n      self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n    }, function (err) {\n      // revert\n      self.volumes.addVolumeToList(volume, sourceId);\n      self.volumes.removeVolumeFromList(volume, targetId);\n\n      _.pull(currentVolumesMovePending, volume.id);\n\n      return $q.reject(err);\n    });\n  };\n  /**\n   * Create a snapshot of given volume.\n   */\n\n\n  this.snapshotVolume = function (volume, snapshotName) {\n    return OvhApiCloudProjectVolumeSnapshot.v6().create({\n      serviceName: self.volumes.serviceName,\n      volumeId: volume.id\n    }, {\n      name: snapshotName\n    }).$promise.then(function () {\n      _.set(volume, 'status', 'snapshotting');\n\n      self.pollVolumes();\n    }, function (err) {\n      return $q.reject(err);\n    });\n  };\n  /* -----  End of VOLUMES  ------*/\n\n  /*= ==============================\n  =            POLLING            =\n  =============================== */\n\n  /**\n   *  --- [Volumes] --- [update] ---\n   *\n   * Updates volumes from API with volumes from this factory\n   *  /!\\ This don't add or remove volumes!\n   */\n\n\n  function updateVolumesWithVolumesFromApi(volumesFromApi, updateOnlySpecificDatas) {\n    var haveChanges = false;\n    angular.forEach(self.volumes.volumes, function (volumesFromFactory, targetId) {\n      if (!volumesFromApi[targetId] || !volumesFromFactory || !volumesFromFactory.length) {\n        return;\n      }\n\n      angular.forEach(volumesFromFactory, function (volumeFromFactory) {\n        var volumeFromApi = _.find(volumesFromApi[targetId], {\n          id: volumeFromFactory.id\n        });\n\n        if (!volumeFromApi) {\n          return;\n        } // If the volume was in pending move, and now active, remove it from pendingArray.\n\n\n        if (~currentVolumesMovePending.indexOf(volumeFromFactory.id) && ~['available', 'in-use'].indexOf(volumeFromApi.status)) {\n          _.pull(currentVolumesMovePending, volumeFromFactory.id);\n        } // If the volume was in snapshotting, and now active display success message\n\n\n        if (volumeFromFactory.status === 'snapshotting' && ~['available', 'in-use'].indexOf(volumeFromApi.status)) {\n          Toast.success($translate.instant('cpci_volume_snapshotting_end', {\n            volume: volumeFromFactory.name\n          }));\n        }\n\n        if (updateOnlySpecificDatas) {\n          // Update status\n          if (volumeFromFactory.status !== volumeFromApi.status) {\n            haveChanges = true;\n\n            _.set(volumeFromFactory, 'status', volumeFromApi.status);\n          }\n        } else {\n          // Updates all infos\n          volumeFromFactory.setInfos(volumeFromApi);\n          haveChanges = true;\n        }\n      });\n    });\n    return haveChanges;\n  }\n  /**\n   *  --- [Volumes] --- [addOrDelete] ---\n   *\n   *  Add or remove volumes from API with volumes from this factory\n   *  /!\\ This can't update existing datas!!!\n   */\n\n\n  function addOrDeleteVolumesWithVolumesFromApi(volumesFromApi, forceRemoveDrafts) {\n    var haveChanges = false;\n    /*= =========  Remove deleted volumes  ========== */\n\n    angular.forEach(self.volumes.volumes, function (volumesFromFactory, targetId) {\n      var deletedVolumes = _.filter(volumesFromFactory, function (vol) {\n        // don't remove drafts!\n        if (!forceRemoveDrafts && vol.status === 'DRAFT') {\n          return false;\n        }\n\n        return !volumesFromApi[targetId] || !_.find(volumesFromApi[targetId], {\n          id: vol.id\n        });\n      });\n\n      angular.forEach(deletedVolumes, function (vol) {\n        // Don't remove pending move\n        if (~currentVolumesMovePending.indexOf(vol.id)) {\n          return;\n        }\n\n        self.volumes.removeVolumeFromList(vol, targetId);\n      });\n      haveChanges = haveChanges || !!deletedVolumes.length;\n    });\n    /*= =========  Add new volumes  ========== */\n\n    angular.forEach(volumesFromApi, function (volumesFromApi, targetId) {\n      // eslint-disable-line\n      var addedVolumes;\n\n      if (!self.volumes.volumes[targetId] || !self.volumes.volumes[targetId].length) {\n        addedVolumes = volumesFromApi;\n      } else {\n        addedVolumes = _.filter(volumesFromApi, function (vol) {\n          return !_.find(self.volumes.volumes[targetId], {\n            id: vol.id\n          });\n        });\n      }\n\n      angular.forEach(addedVolumes, function (vol) {\n        // Don't add pending move\n        if (~currentVolumesMovePending.indexOf(vol.id)) {\n          return;\n        }\n\n        self.volumes.addVolumeToList(vol, targetId);\n      });\n      haveChanges = haveChanges || !!addedVolumes.length;\n    });\n\n    if (haveChanges) {\n      $rootScope.$broadcast('infra.refresh.links');\n    }\n\n    return haveChanges;\n  }\n  /**\n   *  Triggered by polling: Update volumes list\n   *\n   *  /!\\ take care to don't update all datas, user can be in edition for example.\n   */\n\n\n  function updateVolumesFromPolling(volumesParam) {\n    var volumes = volumesParam;\n    var haveChanges = false; // Group by attachedTo\n\n    volumes = _.groupBy(volumes, function (vol) {\n      return vol.attachedTo && vol.attachedTo.length ? vol.attachedTo[0] : 'unlinked';\n    }); // Update existing Volumes\n\n    haveChanges = updateVolumesWithVolumesFromApi(volumes, true) || haveChanges; // Add new Volumes, and delete removed Volumes\n\n    haveChanges = addOrDeleteVolumesWithVolumesFromApi(volumes) || haveChanges;\n\n    if (haveChanges) {\n      self.saveToUserPref();\n    }\n\n    return $q.when(volumes);\n  }\n  /**\n   *  --- [Volumes] --- POLLING ---\n   *\n   *  Poll Volumes query\n   */\n\n\n  this.pollVolumes = function () {\n    var continueStatus = ['creating', 'attaching', 'deleting', 'extending', 'detaching', 'snapshotting'];\n    Poller.poll(\"/cloud/project/\".concat(self.volumes.serviceName, \"/volume\"), null, {\n      successRule: function successRule(volume) {\n        return !~continueStatus.indexOf(volume.status);\n      },\n      namespace: 'cloud.volumes',\n      notifyOnError: false\n    }).then(function (volumes) {\n      updateVolumesFromPolling(volumes);\n    }, function (err) {\n      if (err && err.status) {\n        console.warn('pollVolumes', err); // @todo add bugkiller here\n      }\n    }, function (volumes) {\n      updateVolumesFromPolling(volumes);\n    });\n  };\n  /**\n   *  --- [Volumes] --- POLLING KILL ---\n   *\n   *  Kill the Poll Volumes query\n   */\n\n\n  this.killPollVolumes = function () {\n    Poller.kill({\n      namespace: 'cloud.volumes'\n    });\n  };\n  /* -----  End of Polling  ------*/\n\n  /*= ===================================\n      =            userPref                =\n      ==================================== */\n\n\n  this.saveToUserPref = function () {\n    return CloudUserPref.set(\"cloud_project_\".concat(self.volumes.serviceName, \"_volumes\"), self.volumes.prepareToJson());\n  };\n\n  this.createFromUserPref = function (serviceName) {\n    var key = \"cloud_project_\".concat(serviceName, \"_volumes\");\n    return CloudUserPref.get(key).then(function (volumes) {\n      _.set(volumes, 'serviceName', serviceName);\n\n      return new CloudProjectComputeVolumesFactory(volumes);\n    }, function () {\n      return new CloudProjectComputeVolumesFactory({\n        serviceName: serviceName\n      });\n    });\n  };\n  /*= ===================================================\n  =            LOCAL DATAS UPGRADE (by API)            =\n  ======================================================\n  * =README=\n  * Add, upgrade, and delete VMs or IPs lists with datas from APIs.\n  * Used at initialization, and with polling.\n  **************************************************** */\n\n  /* -----  End of LOCAL DATAS UPGRADE  ------*/\n\n  /*= =====================================\n      =            INITIALISATION            =\n      ====================================== */\n\n  /**\n       * Initialize a volumes list, from existing project.\n       */\n\n\n  function initExistingProject(opts) {\n    return self.createFromUserPref(opts.serviceName).then(function (volumesFromCache) {\n      var initQueue = [];\n      self.volumes = volumesFromCache;\n      /*= =========  Volumes  ========== */\n\n      initQueue.push(OvhApiCloudProjectVolume.v6().query({\n        serviceName: self.volumes.serviceName\n      }).$promise.then(function (volumesParam) {\n        var volumes = volumesParam; // Group by attachedTo\n\n        volumes = _.groupBy(volumes, function (vol) {\n          return vol.attachedTo && vol.attachedTo.length ? vol.attachedTo[0] : 'unlinked';\n        }); // Merge with local datas\n\n        updateVolumesWithVolumesFromApi(volumes);\n        addOrDeleteVolumesWithVolumesFromApi(volumes, true);\n      }));\n      return $q.all(initQueue).then(function () {\n        // WARNING: Never return promise because pulling had to live on her side\n        self.pollVolumes();\n        return self.volumes;\n      });\n    });\n  }\n  /**\n   *  Initialize a new Volumes list, depending of the project's type.\n   */\n\n\n  this.init = function (opts) {\n    resetDatas();\n    return initExistingProject(opts);\n  };\n}]);",null]}