{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/common/cloud-message.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/common/cloud-message.service.js","mtime":1539717142058},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["class CloudMessage {\n  constructor($transitions, $state) {\n    this.$state = $state;\n    this.messages = {};\n    this.subscribers = {};\n\n    $transitions.onSuccess({}, () => {\n      this.flushChildMessage();\n    });\n  }\n\n  success(message, containerName) {\n    this.logMessage(_.isPlainObject(message) ? message : { text: message }, 'success', containerName);\n  }\n\n  error(message, containerName) {\n    this.logMessage(_.isPlainObject(message) ? message : { text: message }, 'error', containerName);\n  }\n\n  warning(message, containerName) {\n    this.logMessage(_.isPlainObject(message) ? message : { text: message }, 'warning', containerName);\n  }\n\n  info(message, containerName) {\n    this.logMessage(_.isPlainObject(message) ? message : { text: message }, 'info', containerName);\n  }\n\n  /*\n   * Handle the message type (error, warning, ...etc) and push the message to the messageHandler\n   */\n  logMessage(messageHash, type, containerName) {\n    if (!messageHash.text && !messageHash.textHtml) {\n      return;\n    }\n\n    const messageHandler = this.getMessageHandler(containerName);\n\n    if (messageHandler) {\n      // Message age defines how many flush the message went through.\n      messageHandler.messages.push(_.extend({\n        type,\n        origin: containerName || this.$state.current.name,\n        timestamp: moment().valueOf(),\n      }, messageHash));\n      messageHandler.onMessage();\n    } else {\n      console.log(`Unhandled message ${messageHash.text}`);\n    }\n  }\n\n  /*\n   * Handle message to dispatch.\n   * @params containerName : custom name for the container\n   * if no params is passed, it will take the current state name as containerName\n   */\n  /* eslint-disable no-param-reassign */\n  getMessageHandler(containerName) {\n    containerName = `${containerName || this.$state.current.name}.`;\n    let messageHandler = null;\n    do {\n      containerName = containerName.substring(0, _.lastIndexOf(containerName, '.'));\n      messageHandler = this.subscribers[containerName];\n    } while (!messageHandler && _.includes(containerName, '.'));\n    return messageHandler;\n  }\n  /* eslint-enable no-param-reassign */\n\n  /*\n   * Retrieve messages\n   */\n  getMessages(containerName) {\n    return this.subscribers[containerName].messages;\n  }\n\n  /*\n   * Flush currents messages\n   */\n  flushMessages(containerName) {\n    const messageHandler = this.getMessageHandler(containerName);\n\n    if (messageHandler) {\n      messageHandler.messages = [];\n      messageHandler.onMessage();\n    }\n  }\n\n  flushChildMessage(containerName) {\n    const messageHandler = this.getMessageHandler(containerName);\n\n    if (messageHandler) {\n      const now = moment().valueOf();\n      messageHandler.messages = _.filter(\n        messageHandler.messages,\n        message => message.origin === messageHandler.containerName\n          || (!message.forceFlush && now - 500 < message.timestamp),\n      );\n\n      _.forEach(messageHandler.messages, (message) => {\n        if (message.origin !== messageHandler.containerName) {\n          _.set(message, 'forceFlush', true);\n        }\n      });\n\n      messageHandler.onMessage();\n    }\n  }\n\n  /*\n   * unsubscribe to the message receiver.\n   */\n  unSubscribe(containerName) {\n    const subscriber = this.subscribers[containerName];\n    if (subscriber) {\n      this.subscribers[containerName].messages = [];\n      this.subscribers[containerName].onMessage();\n    }\n    this.subscribers = _.omit(this.subscribers, containerName);\n  }\n\n  /*\n   * subscibe to the message receiver.\n   * @params containerName : container name or the state name to subscribe\n   * @params params actions to do\n   * ex params : { onMessage: () => this.getMessage() }\n   */\n  subscribe(containerName, params) {\n    this.subscribers[containerName] = _.extend({\n      containerName,\n      messages: [],\n      onMessage: _.noop(),\n    }, params);\n    return {\n      getMessages: () => this.getMessages(containerName),\n    };\n  }\n}\n\nangular.module('managerApp').service('CloudMessage', CloudMessage);\n"]}