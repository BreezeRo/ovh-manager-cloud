{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/storage/services/container.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/storage/services/container.service.js","mtime":1539717142051},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["angular.module('managerApp').service('CloudStorageContainer', [\n  '$cacheFactory',\n  '$http',\n  '$q',\n  'OvhApiCloudProjectStorage',\n  'CloudStorageContainersConfiguration',\n  'CLOUD_PCA_FILE_STATE',\n  function ($cacheFactory, $http, $q,\n    OvhApiCloudProjectStorage, storageContainerConfig, CLOUD_PCA_FILE_STATE) {\n    const self = this;\n\n    // Openstack headers\n    const xStoragePolicy = 'x-storage-policy';\n    const xContainerRead = 'x-container-read';\n    const xContainerMetaWebListings = 'x-container-meta-web-listings';\n    const xContainerReadPublicValue = '.r:*,.rlistings';\n\n    // Cache management\n    const { accessCache } = storageContainerConfig;\n\n    function getAccessAndToken(projectId) {\n      const cacheValue = accessCache.get(projectId);\n\n      const getAccessAndTokenPromise = cacheValue\n        ? $q.resolve(cacheValue)\n        : OvhApiCloudProjectStorage.v6().access({\n          projectId,\n        }, {}).$promise;\n\n      return getAccessAndTokenPromise\n        .then((accessResult) => {\n          if (!cacheValue) {\n            accessCache.put(projectId, accessResult);\n          }\n          self.token = accessResult.token;\n          self.endpoints = accessResult.endpoints.reduce((resultParam, endpoint) => {\n            const result = resultParam;\n            result[endpoint.region.toLowerCase()] = endpoint.url;\n            return result;\n          }, {});\n          return accessResult;\n        });\n    }\n\n    function ensureAccess(projectId) {\n      return getAccessAndToken(projectId);\n    }\n\n    // Improvement:\n    // Avoid listing all containers to get metadata.\n    function getContainerMeta(projectId, containerId) {\n      const containerMeta = storageContainerConfig.containerMetaCache.get(projectId, containerId);\n      return containerMeta\n        ? $q.resolve(containerMeta)\n        : self.list(projectId, containerId)\n          .then(() => storageContainerConfig.containerMetaCache.get(projectId, containerId));\n    }\n\n    function getContainerUrl(baseUrl, containerName, file) {\n      let urlTpl = `${baseUrl}/{container}`;\n      let url;\n      if (file) {\n        urlTpl += '/{file}';\n        url = URI.expand(urlTpl, {\n          container: containerName,\n          file,\n        }).toString();\n      } else {\n        url = URI.expand(urlTpl, {\n          container: containerName,\n        }).toString();\n      }\n      return url;\n    }\n\n    function requestContainer(baseUrl, containerName, optsParam) {\n      const opts = optsParam || {};\n      const url = getContainerUrl(baseUrl, containerName, opts.file);\n      delete opts.file; // eslint-disable-line\n\n      return $http(angular.merge({\n        method: 'GET',\n        url,\n        headers: {\n          'X-Auth-Token': self.token,\n        },\n      }, opts));\n    }\n\n    /**\n     * Get meta data of this container.\n     * @param  {string} projectId     project id\n     * @param  {string} containerId   container id\n     * @return {Promise<Object>}      container metadata\n     */\n    self.getMetaData = function (projectId, containerId) {\n      return ensureAccess(projectId)\n        .then(() => getContainerMeta(projectId, containerId))\n        .then(containerMeta => requestContainer(\n          self.endpoints[containerMeta.region.toLowerCase()],\n          containerMeta.name,\n          { method: 'HEAD' },\n        ))\n        .then(data => _.pick(data.headers(), (value, key) => /^(X-Container|X-Storage)/i.test(key)))\n        .then((data) => {\n          // Guess storage type\n          if (data[xStoragePolicy] === 'PCS') {\n            if (data[xContainerMetaWebListings]) {\n              _.set(data, 'shortcut', 'swift_cname');\n            } else if (data[xContainerRead] === xContainerReadPublicValue) {\n              _.set(data, 'shortcut', 'swift_public');\n            } else {\n              _.set(data, 'shortcut', 'swift_private');\n            }\n          } else {\n            _.set(data, 'shortcut', 'pca');\n          }\n          return data;\n        });\n    };\n\n    /**\n     * List container objects.\n     * @param  {string} projectId     project id\n     * @param  {string} containerId   container id\n     * @return {Promise<Object>}      object containing the list of objects\n     */\n    self.list = function (projectId, containerId) {\n      return OvhApiCloudProjectStorage.v6().get({\n        projectId,\n        containerId,\n      }).$promise\n        .then((containerData) => {\n          storageContainerConfig.containerMetaCache.set(projectId, containerId, _.pick(containerData, ['name', 'region']));\n          return containerData;\n        });\n    };\n\n    /* eslint-disable no-shadow */\n    function upload(url, config) {\n      const deferred = $q.defer();\n      const xhr = new XMLHttpRequest();\n\n      const uploadProgress = function (e) {\n        let res;\n        if (e.lengthComputable) {\n          res = Math.round(e.loaded * 100 / e.total);\n        } else {\n          res = undefined;\n        }\n\n        if (typeof deferred.notify === 'function') {\n          deferred.notify(res);\n        }\n      };\n\n      const uploadComplete = function (e) {\n        const xhr = e.srcElement || e.target;\n        if (xhr.status >= 200 && xhr.status < 300) { // successful upload\n          deferred.resolve(xhr);\n        } else {\n          deferred.reject(xhr);\n        }\n      };\n\n      const uploadFailed = function (e) {\n        const xhr = e.srcElement || e.target;\n        deferred.reject(xhr);\n      };\n\n      const uploadCanceled = function (e) {\n        const xhr = e.srcElement || e.target;\n        deferred.reject(xhr);\n      };\n\n      xhr.upload.addEventListener('progress', uploadProgress, false);\n      xhr.addEventListener('load', uploadComplete, false);\n      xhr.addEventListener('error', uploadFailed, false);\n      xhr.addEventListener('abort', uploadCanceled, false);\n\n      // Send the file\n      xhr.open('PUT', url, true);\n\n      let headers = config.headers || {};\n      headers = angular.extend({\n        'X-Auth-Token': self.token,\n      }, headers);\n\n      angular.forEach(headers, (header, id) => {\n        xhr.setRequestHeader(id, header);\n      });\n      xhr.send(config.data);\n      return deferred.promise;\n    }\n    /* eslint-enable no-shadow */\n\n    /**\n     * Download file.\n     * @param  {string} projectId   project id\n     * @param  {string} containerId container id\n     * @param  {Object} object      object to download\n     * @return {Promise}\n     */\n    self.download = function (projectId, containerId, file) {\n      const weekDurationInMilliseconds = 6.048e+8;\n      const expiration = new Date(Date.now() + weekDurationInMilliseconds);\n\n      function unseal(url) {\n        return $http.get(url)\n          .catch((err) => {\n            // This call make a CORS error, but still initiate the process,\n            // swallow status -1 which is what we get when cors fail.\n            if (err.status !== -1) {\n              throw err;\n            }\n          });\n      }\n\n      return OvhApiCloudProjectStorage.v6().getURL({\n        projectId,\n        containerId,\n      }, {\n        expirationDate: expiration.toISOString(),\n        objectName: file.name,\n      }).$promise\n        .then((resp) => {\n          if (file.retrievalState === CLOUD_PCA_FILE_STATE.SEALED) {\n            return unseal(resp.getURL);\n          }\n          return resp.getURL;\n        });\n    };\n\n    /**\n     * Add object to container.\n     * @param  {string} projectId     project id\n     * @param  {string} containerId   container id\n     * @param  {Object} opts          upload opts\n     * @return {Promise}\n     */\n    self.upload = function (projectId, containerId, opts) {\n      if (!opts.file) {\n        return $q.reject({\n          errorCode: 'BAD_PARAMETERS',\n          config: opts,\n        });\n      }\n      return ensureAccess(projectId)\n        .then(() => getContainerMeta(projectId, containerId))\n        .then((containerMeta) => {\n          const config = {\n            headers: {\n              'Content-Type': opts.file.type,\n            },\n            data: opts.file,\n          };\n          let filename = opts.file.name;\n          if (opts.prefix) {\n            filename = opts.prefix + filename;\n          }\n          const url = getContainerUrl(\n            self.endpoints[containerMeta.region.toLowerCase()],\n            containerMeta.name,\n            filename,\n          );\n          return upload(url, config);\n        });\n    };\n\n    /**\n     * Delete an object.\n     * @param  {string} projectId   project id\n     * @param  {string} containerId container id\n     * @param  {string} file        file name\n     * @return {Promise}\n     */\n    self.delete = function (projectId, containerId, file) {\n      return ensureAccess(projectId)\n        .then(() => getContainerMeta(projectId, containerId))\n        .then(containerMeta => requestContainer(\n          self.endpoints[containerMeta.region.toLowerCase()],\n          containerMeta.name,\n          {\n            method: 'DELETE',\n            file,\n          },\n        ));\n    };\n\n    /**\n     * Set container as public.\n     * @param {string} projectId   project id\n     * @param {string} containerId container id\n     * @return {Promise}\n     */\n    self.setAsPublic = function (projectId, containerId) {\n      return ensureAccess(projectId)\n        .then(() => getContainerMeta(projectId, containerId))\n        .then((containerMeta) => {\n          if (containerMeta[xContainerRead] !== xContainerReadPublicValue) {\n            return requestContainer(\n              self.endpoints[containerMeta.region.toLowerCase()],\n              containerMeta.name,\n              {\n                method: 'PUT',\n                headers: {\n                  'X-Container-Read': xContainerReadPublicValue,\n                },\n              },\n            );\n          }\n          return $.resolve();\n        });\n    };\n\n    self.getAccessAndToken = getAccessAndToken;\n  }]);\n"]}