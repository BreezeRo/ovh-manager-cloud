{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/privateNetwork/dialog/cloud-project-compute-infrastructure-privateNetwork-dialog.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/privateNetwork/dialog/cloud-project-compute-infrastructure-privateNetwork-dialog.service.js","mtime":1539717142000},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable no-bitwise */\nvar CloudProjectComputeInfrastructurePrivateNetworkDialogService =\n/*#__PURE__*/\nfunction () {\n  CloudProjectComputeInfrastructurePrivateNetworkDialogService.$inject = [\"$timeout\", \"OvhApiCloudProjectNetworkPrivate\", \"CloudProjectComputeInfrastructurePrivateNetworkService\"];\n\n  function CloudProjectComputeInfrastructurePrivateNetworkDialogService($timeout, OvhApiCloudProjectNetworkPrivate, CloudProjectComputeInfrastructurePrivateNetworkService) {\n    _classCallCheck(this, CloudProjectComputeInfrastructurePrivateNetworkDialogService);\n\n    _defineProperty(this, \"areRegionsLoading\", function () {\n      return this.Service.areRegionsLoading();\n    });\n\n    _defineProperty(this, \"areUrlsLoading\", function () {\n      return this.Service.areUrlsLoading();\n    });\n\n    _defineProperty(this, \"getUrls\", function () {\n      return this.Service.getUrls;\n    });\n\n    this.$timeout = $timeout;\n    this.OvhApiCloudProjectNetworkPrivate = OvhApiCloudProjectNetworkPrivate;\n    this.Service = CloudProjectComputeInfrastructurePrivateNetworkService;\n  }\n\n  _createClass(CloudProjectComputeInfrastructurePrivateNetworkDialogService, [{\n    key: \"fetchPrivateNetworks\",\n    value: function fetchPrivateNetworks(serviceName) {\n      return this.Service.fetchPrivateNetworks(serviceName);\n    }\n  }, {\n    key: \"arePrivateNetworksLoading\",\n    value: function arePrivateNetworksLoading() {\n      return this.Service.arePrivateNetworksLoading();\n    }\n  }, {\n    key: \"fetchPrivateNetwork\",\n    value: function fetchPrivateNetwork(serviceName, id) {\n      return this.Service.fetchPrivateNetwork(serviceName, id);\n    }\n  }, {\n    key: \"isPrivateNetworkLoading\",\n    value: function isPrivateNetworkLoading() {\n      return this.Service.isPrivateNetworkLoading();\n    }\n  }, {\n    key: \"fetchRegions\",\n    value: function fetchRegions(serviceName) {\n      return this.Service.fetchRegions(serviceName);\n    }\n  }, {\n    key: \"fetchUrls\",\n    value: function fetchUrls() {\n      return this.Service.fetchUrls();\n    }\n  }, {\n    key: \"savePrivateNetwork\",\n    value: function savePrivateNetwork(projectId, privateNetwork, onSuccess) {\n      return this.Service.savePrivateNetwork(projectId, privateNetwork, onSuccess);\n    }\n  }, {\n    key: \"pollPrivateNetworkStatus\",\n    value: function pollPrivateNetworkStatus(options, onSuccess, onFailure) {\n      var _this = this;\n\n      this.$timeout(function () {\n        if (_this.isPrivateNetworkLoading()) {\n          return;\n        }\n\n        _this.OvhApiCloudProjectNetworkPrivate.v6().resetCache();\n\n        _this.fetchPrivateNetwork(options.serviceName, options.privateNetworkId).then(function (network) {\n          if (_this.areAllRegionsActive(network)) {\n            onSuccess(network, options);\n          } else {\n            _this.pollPrivateNetworkStatus(options, onSuccess, onFailure);\n          }\n        }).catch(function (error) {\n          return onFailure(error);\n        });\n      }, options.delay || 2000);\n    }\n  }, {\n    key: \"saveSubnet\",\n    value: function saveSubnet(projectId, networkId, subnet) {\n      return this.Service.saveSubnet(projectId, networkId, subnet);\n    }\n  }, {\n    key: \"isSavePending\",\n    value: function isSavePending() {\n      return this.Service.isSavePending();\n    }\n  }, {\n    key: \"getConstraints\",\n    value: function getConstraints() {\n      return this.Service.getConstraints();\n    }\n  }, {\n    key: \"areAllRegionsActive\",\n    value: function areAllRegionsActive(network) {\n      return this.Service.areAllRegionsActive(network);\n    }\n  }, {\n    key: \"splitSubnetIpAddresses\",\n    value: function splitSubnetIpAddresses(networkMask, networkAddress, numberOfChunk) {\n      var splitData = this.getIpSplitData(networkMask, networkAddress, numberOfChunk);\n      var data = this.validateSplitData(splitData);\n\n      if (!data.isValid) {\n        return data;\n      }\n\n      var chunks = []; // When incrementing the initialIp we always skip 1 IP that will act as the network address\n      // for the IPs block.\n\n      var ipBlockIncrement = 2;\n      var initialIp = splitData.hostAddressInteger + ipBlockIncrement;\n\n      for (var i = 0; i < numberOfChunk; i += 1) {\n        var start = initialIp;\n        var end = start + splitData.chunkSize - 1; // If i is an uneven number, and if we have extras, we distribute one extra.\n\n        if (splitData.extras && i % 2 !== 1) {\n          end += 1;\n          splitData.extras -= 1;\n        }\n\n        chunks.push({\n          start: this.constructor.convertIpIntToIpString(start),\n          end: this.constructor.convertIpIntToIpString(end),\n          total: end - start + 1\n        });\n        initialIp = end + ipBlockIncrement;\n      }\n\n      return {\n        isValid: true,\n        message: '',\n        ipBlocks: chunks\n      };\n    }\n  }, {\n    key: \"getNthNetworkAddress\",\n    value: function getNthNetworkAddress(networkMask, networkAddress, n) {\n      var data = this.validateNetworkData(networkMask, networkAddress, n);\n\n      if (!data.isValid) {\n        return data;\n      }\n\n      var hostBitNumber = this.getNumberOfBitAllocatedToHost(networkMask);\n      var shift = hostBitNumber;\n      var shiftedHostAdressInteger = parseInt(this.constructor.convertIpToByteString(networkAddress), 2) >>> shift;\n      return {\n        isValid: true,\n        message: '',\n        address: this.constructor.convertIpIntToIpString(shiftedHostAdressInteger + n << shift)\n      };\n    }\n  }, {\n    key: \"validateNetworkData\",\n    value: function validateNetworkData(networkMask, networkAddress, n) {\n      var isValid = true;\n      var message = '';\n\n      if (this.isAdressPartOfSubnet(networkMask, networkAddress)) {\n        isValid = false;\n        message = \"The provided network address (\".concat(networkAddress, \") is not part of the subnet \").concat(networkMask, \".\");\n      } else if (n < 1) {\n        isValid = false;\n        message = \"Number of chunk needs to be at least 1.  Provided: \".concat(n, \".\");\n      }\n\n      return {\n        isValid: isValid,\n        message: message\n      };\n    }\n  }, {\n    key: \"getIpSplitData\",\n    value: function getIpSplitData(networkMask, networkAddress, numberOfChunk) {\n      var hostAddressInteger = parseInt(this.constructor.convertIpToByteString(networkAddress), 2);\n      var networkMaskInteger = parseInt(this.constructor.convertIpToByteString(networkMask), 2);\n      var lastHostBit = this.getNumberOfBitAllocatedToHost(networkMask, networkAddress); // Number of total IPs for number of bit available - 1 IP for network address - 1 IP\n      // for broadcast address - numberOfChunk.\n\n      var numberOfUsableIps = Math.pow(2, lastHostBit) - 2 - numberOfChunk; // eslint-disable-line\n\n      var chunkSize = Math.floor(numberOfUsableIps / numberOfChunk);\n      var extras = numberOfUsableIps % numberOfChunk;\n      return {\n        networkMask: networkMask,\n        networkAddress: networkAddress,\n        hostAddressInteger: hostAddressInteger,\n        networkMaskInteger: networkMaskInteger,\n        lastHostBit: lastHostBit,\n        numberOfChunk: numberOfChunk,\n        chunkSize: chunkSize,\n        numberOfUsableIps: numberOfUsableIps,\n        extras: extras\n      };\n    }\n  }, {\n    key: \"validateSplitData\",\n    value: function validateSplitData(splitData) {\n      var isValid = true;\n      var message = '';\n\n      if (splitData.numberOfChunk <= 0) {\n        isValid = false;\n        message = \"Number of chunk needs to be at least 1.  Provided: \".concat(splitData.numberOfChunk, \".\");\n      } else if (this.isAdressPartOfSubnet(splitData.networkMask, splitData.networkAddress)) {\n        isValid = false;\n        message = \"The provided network address (\".concat(splitData.networkAddress, \") is not part of the subnet \").concat(splitData.networkMask, \".\");\n      } else if (splitData.numberOfChunk > splitData.numberOfUsableIps) {\n        isValid = false;\n        message = \"Too few possible addresses (\".concat(splitData.numberOfUsableIps, \") for number of chunks (\").concat(splitData.numberOfChunk, \").  At least 1 address is needed per chunk.\");\n      }\n\n      return {\n        isValid: isValid,\n        message: message\n      };\n    }\n  }, {\n    key: \"isAdressPartOfSubnet\",\n    value: function isAdressPartOfSubnet(networkMask, networkAddress) {\n      var hostBitNumber = this.getNumberOfBitAllocatedToHost(networkMask);\n      var hostAddressInteger = parseInt(this.constructor.convertIpToByteString(networkAddress), 2);\n      var networkMaskInteger = parseInt(this.constructor.convertIpToByteString(networkMask), 2);\n      var shiftedHostAdressInteger = hostAddressInteger >>> hostBitNumber;\n      var shiftedNoetworkMaskInteger = networkMaskInteger >>> hostBitNumber; // Common way to see if an IP is part of a submask.\n      // submask & (bitwise and) ipAddress should equal ipAddress if the IP is part of the submask.\n\n      var bitWiseComparison = shiftedHostAdressInteger & shiftedNoetworkMaskInteger; // If the result is a negative integer, we shift it to unsigned int.\n\n      bitWiseComparison = bitWiseComparison > 0 ? bitWiseComparison : bitWiseComparison >>> 0;\n      return bitWiseComparison !== shiftedHostAdressInteger;\n    }\n  }, {\n    key: \"getNumberOfBitAllocatedToHost\",\n    value: function getNumberOfBitAllocatedToHost(networkMask, networkAddress) {\n      var lastHostMaskBit = this.constructor.convertIpToByteString(networkMask, true).indexOf(1);\n\n      if (!networkAddress) {\n        return lastHostMaskBit;\n      }\n\n      var hostAddressBytes = this.constructor.convertIpToByteString(networkAddress, true);\n      var lastHostAddressBit = hostAddressBytes.indexOf(1);\n      var lastHostBit = 0;\n\n      if (lastHostMaskBit > lastHostAddressBit) {\n        lastHostBit = lastHostAddressBit;\n      } else {\n        lastHostBit = lastHostMaskBit;\n      }\n\n      return lastHostBit;\n    }\n  }], [{\n    key: \"isIPv4\",\n    value: function isIPv4(address) {\n      return /^(\\d{1,3}\\.){3,3}\\d{1,3}$/.test(address);\n    }\n  }, {\n    key: \"convertIpIntToIpString\",\n    value: function convertIpIntToIpString(int) {\n      var part1 = int & 255;\n      var part2 = int >> 8 & 255;\n      var part3 = int >> 16 & 255;\n      var part4 = int >> 24 & 255;\n      return \"\".concat(part4, \".\").concat(part3, \".\").concat(part2, \".\").concat(part1);\n    }\n  }, {\n    key: \"convertIpToByteString\",\n    value: function convertIpToByteString(ip, reverse) {\n      var ipParts = ip.split('.');\n      var byteString = '';\n\n      for (var i = 0; i < ipParts.length; i += 1) {\n        byteString += _.padLeft(parseInt(ipParts[i], 10).toString(2), 8, '0');\n      }\n\n      if (reverse) {\n        return byteString.split('').reverse().join('');\n      }\n\n      return byteString;\n    }\n  }]);\n\n  return CloudProjectComputeInfrastructurePrivateNetworkDialogService;\n}();\n\nangular.module('managerApp').service('CloudProjectComputeInfrastructurePrivateNetworkDialogService', CloudProjectComputeInfrastructurePrivateNetworkDialogService);\n/* eslint-enable no-bitwise */",null]}