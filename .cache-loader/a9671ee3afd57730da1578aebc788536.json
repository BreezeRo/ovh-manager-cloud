{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud-ui/autocomplete/cloud-autocomplete.component.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud-ui/autocomplete/cloud-autocomplete.component.js","mtime":1539717142354},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["AutoCompleteController.$inject = [\"$timeout\", \"$filter\", \"$element\"];\n\nfunction AutoCompleteController($timeout, $filter, $element) {\n  var self = this;\n  self.defaultItemsNumber = 6;\n  self.keys = {\n    arrowUp: 38,\n    arrowDown: 40,\n    escape: 27,\n    enter: 13,\n    tab: 9\n  };\n  self.currentSelection = '';\n  self.$timeout = $timeout;\n  self.$filter = $filter;\n  self.$element = $element;\n}\n\nAutoCompleteController.prototype.openList = function () {\n  this.currentSelection = null;\n  this.arrangeOptions();\n  this.showList = true;\n  this.resetHighlight();\n};\n\nAutoCompleteController.prototype.closeList = function () {\n  // If the user reopened the dropdown after selecting a value and left without selecting one\n  // he didn't change his selection.\n  if (this.ngModel && !this.currentSelection) {\n    this.updateModel(this.ngModel);\n  }\n\n  this.showList = false;\n};\n\nAutoCompleteController.prototype.beginEdit = function () {\n  this.editing = true;\n  this.forceOpen = true;\n  this.openList();\n  this.placeHighlightOnModel();\n};\n\nAutoCompleteController.prototype.endEdit = function () {\n  this.editing = false; // if the user was typing something that is not in the list we need to make sure model is updated.\n\n  if (!this.filteredOptions.length) {\n    this.chooseItem();\n  }\n\n  this.closeList();\n};\n\nAutoCompleteController.prototype.toggleEdit = function () {\n  if (this.editing && !this.forceOpen) {\n    this.endEdit();\n  } else if (!this.editing) {\n    this.beginEdit();\n  } else if (this.forceOpen) {\n    this.forceOpen = false;\n  }\n};\n\nAutoCompleteController.prototype.filterChange = function () {\n  if (this.editing) {\n    this.chooseItem();\n    var selected = this.currentSelection;\n    this.arrangeOptions();\n\n    if (this.filteredOptions.length) {\n      // If the list what closed by a previous filter, we reopen it and apply the user input.\n      if (!this.showList) {\n        this.openList();\n        this.updateSelected(selected);\n        this.filterChange();\n      } else {\n        // else we scroll to the top of the list.\n        this.resetHighlight();\n      }\n    } else {\n      // If the user enter something that is not in the list, we need to update the model object.\n      this.closeList();\n    }\n\n    var list = this.getDomList();\n\n    if (list) {\n      list.scrollTop = 0;\n    }\n  }\n};\n\nAutoCompleteController.prototype.arrangeOptions = function () {\n  this.orderOptions();\n  this.filterOptions(this.currentSelection);\n  this.groupOptions();\n};\n\nAutoCompleteController.prototype.orderOptions = function () {\n  this.options = this.$filter('orderBy')(this.options, this.orderBy);\n};\n\nAutoCompleteController.prototype.filterOptions = function (filter) {\n  if (filter) {\n    var displayProperty = this.displayProperty; // eslint-disable-line\n\n    var filtered = [];\n    var regExp = new RegExp(filter, 'g');\n    angular.forEach(this.options, function (item) {\n      if (item[displayProperty].indexOf(filter) !== -1) {\n        _.set(item, 'filteredProperty', item[displayProperty].replace(regExp, \"<strong>\".concat(filter, \"</strong>\")));\n\n        filtered.push(item);\n      }\n    });\n    this.filteredOptions = filtered;\n  } else {\n    angular.forEach(this.options, function (item) {\n      _.set(item, 'filteredProperty', undefined);\n    });\n    this.filteredOptions = this.options;\n  }\n};\n\nAutoCompleteController.prototype.groupOptions = function () {\n  if (this.groupBy) {\n    this.groupedOptions = _.groupBy(this.filteredOptions, this.groupBy);\n  }\n};\n\nAutoCompleteController.prototype.changeHighlight = function (event) {\n  var keyCode = event.which || event.keyCode;\n\n  switch (keyCode) {\n    case this.keys.arrowUp:\n      if (this.editing) {\n        this.moveHightlightUp();\n        this.updateSelected(this.filteredOptions[this.highlightIndex][this.displayProperty]);\n        event.preventDefault();\n      }\n\n      break;\n\n    case this.keys.arrowDown:\n      if (this.editing) {\n        this.moveHightlightDown();\n        this.updateSelected(this.filteredOptions[this.highlightIndex][this.displayProperty]);\n        event.preventDefault();\n      }\n\n      break;\n\n    case this.keys.enter:\n      if (this.editing) {\n        this.confirmChooseItem(this.filteredOptions[this.highlightIndex]);\n        event.preventDefault();\n      } else {\n        this.beginEdit();\n        event.preventDefault();\n      }\n\n      break;\n\n    case this.keys.tab:\n    case this.keys.escape:\n      if (this.editing) {\n        this.confirmChooseItem(this.filteredOptions[this.highlightIndex]);\n        event.preventDefault();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n};\n\nAutoCompleteController.prototype.confirmChooseItem = function (item, event) {\n  this.chooseItem(item);\n  this.endEdit(); // If an event is present it means that the function was called by the onclick of an element\n  // in which case we don't want it to unfocus the textbox.\n\n  if (event) {\n    event.preventDefault();\n  }\n};\n\nAutoCompleteController.prototype.chooseItem = function (itemParam) {\n  var item = itemParam; // It means that the user decided not to choose something from the list.\n\n  if (!item) {\n    if (this.currentSelection) {\n      item = {};\n      item[this.displayProperty] = this.currentSelection;\n      item.isNew = true;\n    } else {\n      item = null;\n    }\n  }\n\n  this.updateModel(item);\n};\n\nAutoCompleteController.prototype.updateModel = function (newModel) {\n  this.ngModel = newModel;\n\n  if (newModel) {\n    this.updateSelected(newModel[this.displayProperty]);\n  } else {\n    this.updateSelected(null);\n  }\n};\n\nAutoCompleteController.prototype.updateSelected = function (newSelected) {\n  this.currentSelection = newSelected;\n};\n\nAutoCompleteController.prototype.moveHightlightUp = function () {\n  // We check if the user it still editing to avoid DOM errors.\n  if (this.editing) {\n    var list = this.getDomList();\n\n    if (this.highlightIndex !== 0) {\n      this.decrementHighlightIndexes();\n      var elem = this.getDomListItems()[this.highlightIndex];\n\n      if (list.scrollTop > elem.offsetTop) {\n        list.scrollTop = elem.offsetTop;\n      }\n    }\n  }\n};\n\nAutoCompleteController.prototype.moveHightlightDown = function () {\n  // We check if the user it still editing to avoid DOM errors.\n  if (this.editing) {\n    if (this.highlightIndex !== this.filteredOptions.length - 1) {\n      this.incrementHighlightIndexes();\n      this.scrollDownToHighlightedIndex();\n    }\n  }\n};\n\nAutoCompleteController.prototype.scrollDownToHighlightedIndex = function () {\n  var list = this.getDomList();\n  var elem = this.getDomListItems()[this.highlightIndex];\n  var listOffsetBottom = list.clientHeight + list.scrollTop - elem.offsetHeight;\n\n  if (listOffsetBottom < elem.offsetTop) {\n    var scrollPosition = elem.offsetTop + elem.offsetHeight - list.clientHeight;\n    list.scrollTop = scrollPosition;\n  }\n};\n\nAutoCompleteController.prototype.getDomList = function () {\n  return document.querySelector('.cloud-autocomplete__list');\n};\n\nAutoCompleteController.prototype.getDomListItems = function () {\n  return document.querySelectorAll('.cloud-autocomplete__list__item');\n};\n\nAutoCompleteController.prototype.preventEvent = function (event) {\n  event.preventDefault();\n};\n\nAutoCompleteController.prototype.incrementHighlightIndexes = function () {\n  this.highlightIndex += 1;\n  this.highlightedGroupIndex += 1;\n  this.adjustHighlightGroupIndexes('down');\n};\n\nAutoCompleteController.prototype.decrementHighlightIndexes = function () {\n  this.highlightIndex -= 1;\n  this.highlightedGroupIndex -= 1;\n  this.adjustHighlightGroupIndexes('up');\n};\n\nAutoCompleteController.prototype.adjustHighlightGroupIndexes = function (direction) {\n  if (this.groupBy) {\n    var currItem = this.filteredOptions[this.highlightIndex];\n    this.highlightedGroupKey = this.getArrangedGroupName(currItem[this.groupBy]);\n    var precItem = null;\n\n    switch (direction) {\n      case 'up':\n        // If we changed group and we are going up, we are on the last element\n        // of the previous group.\n        precItem = this.filteredOptions[this.highlightIndex + 1];\n\n        if (!precItem || precItem[this.groupBy] !== currItem[this.groupBy]) {\n          this.highlightedGroupIndex = this.groupedOptions[currItem[this.groupBy]].length - 1;\n        }\n\n        break;\n\n      default:\n        // If we changed group and we are going down, we are on the first element of the next group.\n        precItem = this.filteredOptions[this.highlightIndex - 1];\n\n        if (!precItem || precItem[this.groupBy] !== currItem[this.groupBy]) {\n          this.highlightedGroupIndex = 0;\n        }\n\n        break;\n    }\n  }\n};\n\nAutoCompleteController.prototype.placeHighlightOnModel = function () {\n  // When we open the dropdown and a selection was made beforehand\n  // we have to scroll and highlight the selected item.\n  if (this.ngModel && !this.ngModel.isNew) {\n    var selectedModel = this.ngModel;\n    this.highlightIndex = _.findIndex(this.options, function (item) {\n      return item === selectedModel;\n    });\n\n    if (this.groupBy) {\n      this.highlightedGroupKey = this.getArrangedGroupName(this.options[this.highlightIndex][this.groupBy]);\n      var optionToFind = this.options[this.highlightIndex];\n      this.highlightedGroupIndex = _.findIndex(this.groupedOptions[this.highlightedGroupKey], function (item) {\n        return item === optionToFind;\n      });\n    }\n\n    this.$timeout(this.scrollDownToHighlightedIndex.bind(this));\n  }\n};\n\nAutoCompleteController.prototype.resetHighlight = function () {\n  this.highlightIndex = 0;\n\n  if (this.groupBy) {\n    this.highlightedGroupKey = this.getArrangedGroupName(this.filteredOptions[0][this.groupBy]);\n    this.highlightedGroupIndex = 0;\n  }\n};\n\nAutoCompleteController.prototype.getArrangedGroupName = function (groupName) {\n  return _.isUndefined(groupName) ? 'undefined' : groupName;\n};\n\nangular.module('managerApp').component('cloudAutoComplete', {\n  templateUrl: 'components/cloud-ui/autocomplete/autocomplete.html',\n  controller: AutoCompleteController,\n  bindings: {\n    id: '@',\n    // The client ID of the input.  Allows to associate a label with the input.\n    name: '@?',\n    // The client name of the input.  Allows to associate a label with the input.\n    options: '<',\n    // Options to display in the list.\n    groupBy: '@',\n    // options will be grouped by this property.  The component support 1 level of grouping only.\n    orderBy: '<',\n    // The order in which we want to order options.  Works like the orderBy in ngRepeat.\n    displayProperty: '@',\n    // Given that options is an array of object, the list will display the property described by  displayProperty in the list.\n    ngModel: '=',\n    // The model that will be updated when the user select a value.\n    ngRequired: '<',\n    // if true the user will have to fill the field.\n    ngDisabled: '<',\n    // if true the user won't be able to activate the field.\n    groupDescription: '@',\n    // Display an item when the list is grouped that explain what is in the list.  (Like: My OVH services, IPs, etc.)\n    placeholder: '@' // A placeholder to show when the input is empty.\n\n  }\n});",null]}