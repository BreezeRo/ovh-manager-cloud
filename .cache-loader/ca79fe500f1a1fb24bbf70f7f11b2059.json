{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/virtualMachine/monitoring/cloud-project-compute-infrastructure-virtualMachine-monitoring.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/virtualMachine/monitoring/cloud-project-compute-infrastructure-virtualMachine-monitoring.controller.js","mtime":1539717142013},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["angular.module('managerApp').controller('CloudProjectComputeInfrastructureVirtualMachineMonitoringCtrl', [\"$rootScope\", \"$scope\", \"$q\", \"$timeout\", \"CloudProjectComputeInfrastructureOrchestrator\", \"OvhApiCloudProjectInstance\", \"CLOUD_MONITORING\", \"CLOUD_UNIT_CONVERSION\", function CloudProjectComputeInfrastructureVirtualMachineMonitoringCtrl($rootScope, $scope, $q, $timeout, CloudProjectComputeInfrastructureOrchestrator, OvhApiCloudProjectInstance, CLOUD_MONITORING, CLOUD_UNIT_CONVERSION) {\n  var self = this;\n  self.vm = null;\n  this.loaders = {\n    monitoring: {\n      'cpu:used': false,\n      'mem:used': false,\n      'net:rx': false,\n      'net:tx': false\n    }\n  };\n  this.dataPeriod = {\n    cpu: {\n      max: undefined,\n      needUpgrade: undefined\n    },\n    mem: {\n      max: undefined,\n      needUpgrade: undefined\n    },\n    net: {\n      up: {\n        max: undefined,\n        needUpgrade: undefined\n      },\n      down: {\n        max: undefined,\n        needUpgrade: undefined\n      }\n    }\n  };\n  self.accordions = {\n    cpu: false,\n    mem: false,\n    net: false\n  };\n  self.chartData = {\n    'cpu:used': null,\n    'mem:used': null,\n    'net:rx': null,\n    'net:tx': null\n  }; // list of available periods to select for monitoring chart\n\n  self.chartPeriodEnum = ['lastday', 'lastweek', 'lastmonth', 'lastyear']; // currently selected period for each monitoring chart\n\n  self.selectedChartPeriod = {\n    'cpu:used': 'lastweek',\n    'mem:used': 'lastweek',\n    'net:rx': 'lastweek',\n    'net:tx': 'lastweek'\n  };\n\n  self.close = function close() {\n    self.vm.stopMonitoring();\n    $rootScope.$broadcast('highlighed-element.hide', \"compute,\".concat(self.vm.id));\n  };\n\n  self.openVmFlavorEditionState = function openVmFlavorEditionState() {\n    CloudProjectComputeInfrastructureOrchestrator.setEditVmParam('FLAVOR');\n    CloudProjectComputeInfrastructureOrchestrator.turnOnVmEdition(self.vm);\n  };\n\n  function getDefaultScale(rawData) {\n    return {\n      divisionScale: 1,\n      unit: rawData.unit\n    };\n  }\n\n  function scaleData(rawData) {\n    var maxValue = _.chain(rawData.values).map(function (timeSerie) {\n      return timeSerie.value;\n    }).max().value();\n\n    var divisionScale;\n    var unit;\n\n    if (maxValue / CLOUD_UNIT_CONVERSION.GIGABYTE_TO_BYTE >= 1) {\n      divisionScale = CLOUD_UNIT_CONVERSION.GIGABYTE_TO_BYTE;\n      unit = 'gb/s';\n    } else if (maxValue / CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE >= 1) {\n      divisionScale = CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE;\n      unit = 'mb/s';\n    } else if (maxValue / CLOUD_UNIT_CONVERSION.KILOBYTE_TO_BYTE >= 1) {\n      divisionScale = CLOUD_UNIT_CONVERSION.KILOBYTE_TO_BYTE;\n      unit = 'kb/s';\n    } else {\n      divisionScale = 1;\n      unit = 'b/s';\n    }\n\n    return {\n      divisionScale: divisionScale,\n      unit: unit\n    };\n  } // get a good timescale to display values over a given period\n\n\n  function getPeriodTimeScale(period) {\n    switch (period) {\n      case 'lastday':\n        return {\n          unit: 'hours',\n          amount: 2,\n          format: '%Hh'\n        };\n\n      case 'lastweek':\n        return {\n          unit: 'days',\n          amount: 1,\n          format: '%d/%m'\n        };\n\n      case 'lastmonth':\n        return {\n          unit: 'weeks',\n          amount: 1,\n          format: '%d/%m'\n        };\n\n      case 'lastyear':\n        return {\n          unit: 'months',\n          amount: 1,\n          format: '%m'\n        };\n\n      default:\n        return {\n          unit: 'days',\n          amount: 1,\n          format: '%Hh'\n        };\n    }\n  }\n\n  function getPeriodStart(period) {\n    var oneDay = 1000 * 60 * 60 * 24; // in ms\n\n    switch (period) {\n      case 'lastday':\n        return new Date().getTime() - oneDay;\n\n      case 'lastweek':\n        return new Date().getTime() - 7 * oneDay;\n\n      case 'lastmonth':\n        return new Date().getTime() - 31 * oneDay;\n\n      case 'lastyear':\n        return new Date().getTime() - 365 * oneDay;\n\n      default:\n        return null;\n    }\n  } // updates monitoring chart with given data from api\n\n\n  function updateChart(type, period, rawData) {\n    var scaledData;\n    scaledData = getDefaultScale(rawData);\n\n    if (type === 'net:rx' || type === 'net:tx') {\n      scaledData = scaleData(rawData);\n    }\n\n    var _scaledData = scaledData,\n        divisionScale = _scaledData.divisionScale,\n        unit = _scaledData.unit;\n\n    var data = _.map(rawData.values, function (e) {\n      return {\n        timestamp: e.timestamp * 1000,\n        // unix to js timestamp\n        value: e.value / divisionScale\n      };\n    });\n\n    if (data.length) {\n      var chartData = {\n        data: data,\n        ymin: 0,\n        xmin: getPeriodStart(period),\n        xmax: new Date().getTime(),\n        unit: unit,\n        margin: {\n          top: 10,\n          left: 55,\n          bottom: 30,\n          right: 10\n        },\n        timeScale: getPeriodTimeScale(period)\n      };\n\n      if (type === 'mem:used' && self.vm.monitoringData && self.vm.monitoringData.mem && self.vm.monitoringData.mem.total) {\n        chartData.ymax = self.vm.monitoringData.mem.total.value;\n      }\n\n      self.chartData[type] = chartData;\n    }\n  }\n\n  function closeOnEscapeKey(evt) {\n    if (evt.which === 27) {\n      self.close();\n    }\n\n    $scope.$apply();\n  }\n\n  function updateMaxCPUPercentageForPeriod(data) {\n    self.dataPeriod.cpu.max = _.max(data.values, function (v) {\n      return angular.isNumber(v.value) ? v.value : Number.NEGATIVE_INFINITY;\n    }).value;\n    self.dataPeriod.cpu.needUpgrade = self.dataPeriod.cpu.max >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n    self.accordions.cpu = self.accordions.cpu || self.dataPeriod.cpu.needUpgrade;\n  }\n\n  function updateMaxRAMPercentageForPeriod(data) {\n    var total = _.last(self.vm.monitoringData.raw['mem:max'].values).value;\n\n    var maxUsed = _.max(data.values, function (v) {\n      return angular.isNumber(v.value) ? v.value : Number.NEGATIVE_INFINITY;\n    }).value;\n\n    self.dataPeriod.mem.max = maxUsed / total * 100;\n    self.dataPeriod.mem.needUpgrade = self.dataPeriod.mem.max >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n    self.accordions.mem = self.accordions.mem || self.dataPeriod.mem.needUpgrade;\n  }\n\n  function updateMaxNETUpPercentageForPeriod(data) {\n    var total = self.vm.flavor.inboundBandwidth * CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE;\n\n    var maxUsed = _.max(data.values, function (v) {\n      return angular.isNumber(v.value) ? v.value : Number.NEGATIVE_INFINITY;\n    }).value;\n\n    self.dataPeriod.net.up.max = maxUsed / total * 100;\n    self.dataPeriod.net.up.needUpgrade = self.dataPeriod.net.up.max >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n    self.accordions.net = self.accordions.net || self.dataPeriod.net.up.needUpgrade;\n  }\n\n  function updateMaxNETDownPercentageForPeriod(data) {\n    var total = self.vm.flavor.outboundBandwidth * CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE;\n\n    var maxUsed = _.max(data.values, function (v) {\n      return angular.isNumber(v.value) ? v.value : Number.NEGATIVE_INFINITY;\n    }).value;\n\n    self.dataPeriod.net.down.max = maxUsed / total * 100;\n    self.dataPeriod.net.down.needUpgrade = self.dataPeriod.net.down.max >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n    self.accordions.net = self.accordions.net || self.dataPeriod.net.down.needUpgrade;\n  }\n\n  function updateChartsWithMonitoringData(data) {\n    if (data['cpu:used']) {\n      updateChart('cpu:used', self.selectedChartPeriod['cpu:used'], data['cpu:used']);\n    }\n\n    if (data['mem:used']) {\n      updateChart('mem:used', self.selectedChartPeriod['mem:used'], data['mem:used']);\n    }\n\n    if (data['net:tx']) {\n      updateChart('net:tx', self.selectedChartPeriod['net:tx'], data['net:tx']);\n    }\n\n    if (data['net:rx']) {\n      updateChart('net:rx', self.selectedChartPeriod['net:rx'], data['net:rx']);\n    }\n  }\n\n  function updateMaxPercentageForPeriod(data) {\n    updateMaxCPUPercentageForPeriod(data['cpu:used']);\n    updateMaxRAMPercentageForPeriod(data['mem:used']);\n    updateMaxNETDownPercentageForPeriod(data['net:tx']);\n    updateMaxNETUpPercentageForPeriod(data['net:rx']);\n  }\n\n  function updateMaxTypePercentageForPeriod(type, data) {\n    if (type === 'cpu:used') {\n      updateMaxCPUPercentageForPeriod(data);\n    }\n\n    if (type === 'mem:used') {\n      updateMaxRAMPercentageForPeriod(data);\n    }\n\n    if (type === 'net:tx') {\n      updateMaxNETDownPercentageForPeriod(data);\n    }\n\n    if (type === 'net:rx') {\n      updateMaxNETUpPercentageForPeriod(data);\n    }\n  } // on period change, reload monitoring data and update chart\n\n\n  self.onChartPeriodChanged = function onChartPeriodChanged(type) {\n    var period = self.selectedChartPeriod[type];\n    self.loaders.monitoring[type] = true;\n    OvhApiCloudProjectInstance.v6().resetAllCache();\n    OvhApiCloudProjectInstance.v6().monitoring({\n      serviceName: self.vm.serviceName,\n      instanceId: self.vm.id,\n      period: period,\n      type: type\n    }).$promise.then(function (data) {\n      updateChart(type, period, data);\n      updateMaxTypePercentageForPeriod(type, data);\n    }, function () {\n      self.chartData[type] = null;\n    }).finally(function () {\n      self.loaders.monitoring[type] = false;\n    });\n  };\n\n  function init() {\n    self.vm = CloudProjectComputeInfrastructureOrchestrator.getMonitoredVm();\n    $rootScope.$broadcast('highlighed-element.show', \"compute,\".concat(self.vm.id));\n    $(document).on('keyup', closeOnEscapeKey);\n    $scope.$on('$destroy', function () {\n      $(document).off('keyup', closeOnEscapeKey);\n    });\n\n    if (self.vm.monitoringData) {\n      updateChartsWithMonitoringData(self.vm.monitoringData.raw);\n      updateMaxPercentageForPeriod(self.vm.monitoringData.raw);\n    } else {\n      self.vm.getMonitoringData().finally(function () {\n        if (self.vm.monitoringData) {\n          updateChartsWithMonitoringData(self.vm.monitoringData.raw);\n          updateMaxPercentageForPeriod(self.vm.monitoringData.raw);\n        }\n      });\n    }\n\n    $scope.$watch('VmMonitoringCtrl.accordions.cpu', function (oldValue) {\n      if (oldValue) {\n        self.accordions.mem = false;\n        self.accordions.net = false;\n      }\n    }, true);\n    $scope.$watch('VmMonitoringCtrl.accordions.mem', function (oldValue) {\n      if (oldValue) {\n        self.accordions.cpu = false;\n        self.accordions.net = false;\n      }\n    }, true);\n    $scope.$watch('VmMonitoringCtrl.accordions.net', function (oldValue) {\n      if (oldValue) {\n        self.accordions.mem = false;\n        self.accordions.cpu = false;\n      }\n    }, true);\n  }\n\n  $timeout(function () {\n    init();\n  });\n}]);",null]}