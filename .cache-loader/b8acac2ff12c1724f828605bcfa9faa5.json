{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/virtualMachine/monitoring/cloud-project-compute-infrastructure-virtualMachine-monitoring.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/virtualMachine/monitoring/cloud-project-compute-infrastructure-virtualMachine-monitoring.controller.js","mtime":1539717142013},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["angular.module('managerApp')\n  .controller('CloudProjectComputeInfrastructureVirtualMachineMonitoringCtrl',\n    function CloudProjectComputeInfrastructureVirtualMachineMonitoringCtrl($rootScope, $scope, $q,\n      $timeout, CloudProjectComputeInfrastructureOrchestrator, OvhApiCloudProjectInstance,\n      CLOUD_MONITORING, CLOUD_UNIT_CONVERSION) {\n      const self = this;\n\n      self.vm = null;\n\n      this.loaders = {\n        monitoring: {\n          'cpu:used': false,\n          'mem:used': false,\n          'net:rx': false,\n          'net:tx': false,\n        },\n      };\n\n      this.dataPeriod = {\n        cpu: {\n          max: undefined,\n          needUpgrade: undefined,\n        },\n        mem: {\n          max: undefined,\n          needUpgrade: undefined,\n        },\n        net: {\n          up: {\n            max: undefined,\n            needUpgrade: undefined,\n          },\n          down: {\n            max: undefined,\n            needUpgrade: undefined,\n          },\n        },\n      };\n\n      self.accordions = {\n        cpu: false,\n        mem: false,\n        net: false,\n      };\n\n      self.chartData = {\n        'cpu:used': null,\n        'mem:used': null,\n        'net:rx': null,\n        'net:tx': null,\n      };\n\n      // list of available periods to select for monitoring chart\n      self.chartPeriodEnum = [\n        'lastday',\n        'lastweek',\n        'lastmonth',\n        'lastyear',\n      ];\n\n      // currently selected period for each monitoring chart\n      self.selectedChartPeriod = {\n        'cpu:used': 'lastweek',\n        'mem:used': 'lastweek',\n        'net:rx': 'lastweek',\n        'net:tx': 'lastweek',\n      };\n\n      self.close = function close() {\n        self.vm.stopMonitoring();\n        $rootScope.$broadcast('highlighed-element.hide', `compute,${self.vm.id}`);\n      };\n\n      self.openVmFlavorEditionState = function openVmFlavorEditionState() {\n        CloudProjectComputeInfrastructureOrchestrator.setEditVmParam('FLAVOR');\n        CloudProjectComputeInfrastructureOrchestrator.turnOnVmEdition(self.vm);\n      };\n\n      function getDefaultScale(rawData) {\n        return {\n          divisionScale: 1,\n          unit: rawData.unit,\n        };\n      }\n\n      function scaleData(rawData) {\n        const maxValue = _.chain(rawData.values)\n          .map(timeSerie => timeSerie.value)\n          .max()\n          .value();\n        let divisionScale;\n        let unit;\n\n        if (maxValue / CLOUD_UNIT_CONVERSION.GIGABYTE_TO_BYTE >= 1) {\n          divisionScale = CLOUD_UNIT_CONVERSION.GIGABYTE_TO_BYTE;\n          unit = 'gb/s';\n        } else if (maxValue / CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE >= 1) {\n          divisionScale = CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE;\n          unit = 'mb/s';\n        } else if (maxValue / CLOUD_UNIT_CONVERSION.KILOBYTE_TO_BYTE >= 1) {\n          divisionScale = CLOUD_UNIT_CONVERSION.KILOBYTE_TO_BYTE;\n          unit = 'kb/s';\n        } else {\n          divisionScale = 1;\n          unit = 'b/s';\n        }\n\n        return {\n          divisionScale,\n          unit,\n        };\n      }\n\n      // get a good timescale to display values over a given period\n      function getPeriodTimeScale(period) {\n        switch (period) {\n          case 'lastday':\n            return { unit: 'hours', amount: 2, format: '%Hh' };\n          case 'lastweek':\n            return { unit: 'days', amount: 1, format: '%d/%m' };\n          case 'lastmonth':\n            return { unit: 'weeks', amount: 1, format: '%d/%m' };\n          case 'lastyear':\n            return { unit: 'months', amount: 1, format: '%m' };\n          default:\n            return { unit: 'days', amount: 1, format: '%Hh' };\n        }\n      }\n\n      function getPeriodStart(period) {\n        const oneDay = 1000 * 60 * 60 * 24; // in ms\n        switch (period) {\n          case 'lastday':\n            return new Date().getTime() - oneDay;\n          case 'lastweek':\n            return new Date().getTime() - 7 * oneDay;\n          case 'lastmonth':\n            return new Date().getTime() - 31 * oneDay;\n          case 'lastyear':\n            return new Date().getTime() - 365 * oneDay;\n          default:\n            return null;\n        }\n      }\n\n      // updates monitoring chart with given data from api\n      function updateChart(type, period, rawData) {\n        let scaledData;\n\n        scaledData = getDefaultScale(rawData);\n\n        if (type === 'net:rx' || type === 'net:tx') {\n          scaledData = scaleData(rawData);\n        }\n\n        const { divisionScale, unit } = scaledData;\n\n        const data = _.map(rawData.values, e => ({\n          timestamp: e.timestamp * 1000, // unix to js timestamp\n          value: e.value / divisionScale,\n        }));\n        if (data.length) {\n          const chartData = {\n            data,\n            ymin: 0,\n            xmin: getPeriodStart(period),\n            xmax: new Date().getTime(),\n            unit,\n            margin: {\n              top: 10, left: 55, bottom: 30, right: 10,\n            },\n            timeScale: getPeriodTimeScale(period),\n          };\n          if (type === 'mem:used' && self.vm.monitoringData && self.vm.monitoringData.mem\n                    && self.vm.monitoringData.mem.total) {\n            chartData.ymax = self.vm.monitoringData.mem.total.value;\n          }\n          self.chartData[type] = chartData;\n        }\n      }\n\n      function closeOnEscapeKey(evt) {\n        if (evt.which === 27) {\n          self.close();\n        }\n        $scope.$apply();\n      }\n\n      function updateMaxCPUPercentageForPeriod(data) {\n        self.dataPeriod.cpu.max = _.max(\n          data.values,\n          v => (angular.isNumber(v.value)\n            ? v.value\n            : Number.NEGATIVE_INFINITY),\n        ).value;\n        self.dataPeriod.cpu.needUpgrade = self.dataPeriod.cpu.max\n          >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n        self.accordions.cpu = self.accordions.cpu || self.dataPeriod.cpu.needUpgrade;\n      }\n\n      function updateMaxRAMPercentageForPeriod(data) {\n        const total = _.last(self.vm.monitoringData.raw['mem:max'].values).value;\n        const maxUsed = _.max(\n          data.values,\n          v => (angular.isNumber(v.value)\n            ? v.value\n            : Number.NEGATIVE_INFINITY),\n        ).value;\n        self.dataPeriod.mem.max = maxUsed / total * 100;\n        self.dataPeriod.mem.needUpgrade = self.dataPeriod.mem.max\n          >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n        self.accordions.mem = self.accordions.mem || self.dataPeriod.mem.needUpgrade;\n      }\n\n      function updateMaxNETUpPercentageForPeriod(data) {\n        const total = self.vm.flavor.inboundBandwidth * CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE;\n        const maxUsed = _.max(\n          data.values,\n          v => (angular.isNumber(v.value)\n            ? v.value\n            : Number.NEGATIVE_INFINITY),\n        ).value;\n        self.dataPeriod.net.up.max = maxUsed / total * 100;\n        self.dataPeriod.net.up.needUpgrade = self.dataPeriod.net.up.max\n          >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n        self.accordions.net = self.accordions.net || self.dataPeriod.net.up.needUpgrade;\n      }\n\n      function updateMaxNETDownPercentageForPeriod(data) {\n        const total = self.vm.flavor.outboundBandwidth * CLOUD_UNIT_CONVERSION.MEGABYTE_TO_BYTE;\n        const maxUsed = _.max(\n          data.values,\n          v => (angular.isNumber(v.value)\n            ? v.value\n            : Number.NEGATIVE_INFINITY),\n        ).value;\n        self.dataPeriod.net.down.max = maxUsed / total * 100;\n        self.dataPeriod.net.down.needUpgrade = self.dataPeriod.net.down.max\n          >= CLOUD_MONITORING.vm.upgradeAlertThreshold;\n        self.accordions.net = self.accordions.net || self.dataPeriod.net.down.needUpgrade;\n      }\n\n      function updateChartsWithMonitoringData(data) {\n        if (data['cpu:used']) {\n          updateChart('cpu:used', self.selectedChartPeriod['cpu:used'], data['cpu:used']);\n        }\n        if (data['mem:used']) {\n          updateChart('mem:used', self.selectedChartPeriod['mem:used'], data['mem:used']);\n        }\n        if (data['net:tx']) {\n          updateChart('net:tx', self.selectedChartPeriod['net:tx'], data['net:tx']);\n        }\n        if (data['net:rx']) {\n          updateChart('net:rx', self.selectedChartPeriod['net:rx'], data['net:rx']);\n        }\n      }\n\n      function updateMaxPercentageForPeriod(data) {\n        updateMaxCPUPercentageForPeriod(data['cpu:used']);\n        updateMaxRAMPercentageForPeriod(data['mem:used']);\n        updateMaxNETDownPercentageForPeriod(data['net:tx']);\n        updateMaxNETUpPercentageForPeriod(data['net:rx']);\n      }\n\n      function updateMaxTypePercentageForPeriod(type, data) {\n        if (type === 'cpu:used') {\n          updateMaxCPUPercentageForPeriod(data);\n        }\n        if (type === 'mem:used') {\n          updateMaxRAMPercentageForPeriod(data);\n        }\n        if (type === 'net:tx') {\n          updateMaxNETDownPercentageForPeriod(data);\n        }\n        if (type === 'net:rx') {\n          updateMaxNETUpPercentageForPeriod(data);\n        }\n      }\n\n      // on period change, reload monitoring data and update chart\n      self.onChartPeriodChanged = function onChartPeriodChanged(type) {\n        const period = self.selectedChartPeriod[type];\n        self.loaders.monitoring[type] = true;\n        OvhApiCloudProjectInstance.v6().resetAllCache();\n        OvhApiCloudProjectInstance.v6().monitoring({\n          serviceName: self.vm.serviceName,\n          instanceId: self.vm.id,\n          period,\n          type,\n        }).$promise.then((data) => {\n          updateChart(type, period, data);\n          updateMaxTypePercentageForPeriod(type, data);\n        }, () => {\n          self.chartData[type] = null;\n        }).finally(() => {\n          self.loaders.monitoring[type] = false;\n        });\n      };\n\n      function init() {\n        self.vm = CloudProjectComputeInfrastructureOrchestrator.getMonitoredVm();\n        $rootScope.$broadcast('highlighed-element.show', `compute,${self.vm.id}`);\n\n        $(document).on('keyup', closeOnEscapeKey);\n        $scope.$on('$destroy', () => {\n          $(document).off('keyup', closeOnEscapeKey);\n        });\n\n        if (self.vm.monitoringData) {\n          updateChartsWithMonitoringData(self.vm.monitoringData.raw);\n          updateMaxPercentageForPeriod(self.vm.monitoringData.raw);\n        } else {\n          self.vm.getMonitoringData().finally(() => {\n            if (self.vm.monitoringData) {\n              updateChartsWithMonitoringData(self.vm.monitoringData.raw);\n              updateMaxPercentageForPeriod(self.vm.monitoringData.raw);\n            }\n          });\n        }\n\n        $scope.$watch('VmMonitoringCtrl.accordions.cpu', (oldValue) => {\n          if (oldValue) {\n            self.accordions.mem = false;\n            self.accordions.net = false;\n          }\n        }, true);\n\n        $scope.$watch('VmMonitoringCtrl.accordions.mem', (oldValue) => {\n          if (oldValue) {\n            self.accordions.cpu = false;\n            self.accordions.net = false;\n          }\n        }, true);\n\n        $scope.$watch('VmMonitoringCtrl.accordions.net', (oldValue) => {\n          if (oldValue) {\n            self.accordions.mem = false;\n            self.accordions.cpu = false;\n          }\n        }, true);\n      }\n\n      $timeout(() => {\n        init();\n      });\n    });\n"]}