{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/privateNetwork/dialog/cloud-project-compute-infrastructure-privateNetwork-dialog.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/privateNetwork/dialog/cloud-project-compute-infrastructure-privateNetwork-dialog.controller.js","mtime":1539717141999},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["angular.module('managerApp').controller('CloudProjectComputeInfrastructurePrivateNetworkDialogCtrl',\n  function ($rootScope, $scope, $q, $timeout, $translate, $stateParams,\n    CloudProjectComputeInfrastructurePrivateNetworkDialogService, RegionService) {\n    const self = this;\n\n    self.projectId = $stateParams.projectId;\n\n    self.service = CloudProjectComputeInfrastructurePrivateNetworkDialogService;\n    self.regionService = RegionService;\n\n    self.form = null;\n\n    self.models = {\n      privateNetwork: {\n        name: null,\n        vlanId: 0,\n        regions: [],\n      },\n      subnet: {\n        address: null,\n        mask: 24,\n        dhcp: true,\n      },\n      subnets: [],\n    };\n\n    self.collections = {\n      privateNetworks: [],\n    };\n\n    self.states = {\n      description: {\n        edit: false,\n      },\n      page: 'menu',\n      switch: null,\n      vlan: false,\n      untagged: false,\n    };\n\n    self.userInput = {\n      vlanId: 0,\n    };\n\n    self.constraints = self.service.getConstraints();\n\n    function init() {\n      $q.all([\n        self.fetchPrivateNetworks(),\n        self.fetchRegions(),\n      ]).then(() => {\n        self.presetNetwork(self.userInput.vlanId);\n      }).finally(() => {\n        $rootScope.$broadcast('highlighed-element.show', 'compute');\n      });\n\n      if (!self.service.areUrlsLoading()) {\n        self.service.fetchUrls();\n      }\n\n      $scope.$on('responsive.switch.created', (event, _switch) => {\n        self.states.switch = _switch;\n      });\n    }\n\n    self.fetchPrivateNetworks = function () {\n      if (self.service.arePrivateNetworksLoading()) {\n        return $q.when();\n      }\n\n      return self.service.fetchPrivateNetworks(self.projectId).then((networks) => {\n        self.collections.privateNetworks = networks;\n        self.states.untagged = self.hasUntaggedVlan(networks);\n        self.models.privateNetwork.vlanId = self.userInput.vlanId;\n        self.userInput.vlanId = self.getNextId(networks);\n\n        if (self.states.untagged) {\n          self.states.vlan = true;\n          self.models.privateNetwork.vlanId = self.userInput.vlanId;\n        }\n\n        self.models.privateNetwork.name = $translate.instant('cpcipnd_default_name_template');\n      }).catch(() => {\n        self.collections.privateNetworks = [];\n      });\n    };\n\n    self.getGlobalNetwork = function () {\n      return [self.models.subnet.address, self.models.subnet.mask].join('/');\n    };\n\n    self.getPrivateNetwork = function () {\n      return self.models.privateNetwork;\n    };\n\n    self.getSubnetTemplate = function () {\n      return self.models.subnet;\n    };\n\n    self.isDHCPEnabled = function () {\n      return self.models.subnet.dhcp;\n    };\n\n    self.fetchRegions = function () {\n      if (self.service.areRegionsLoading()) {\n        return $q.when();\n      }\n\n      return self.service.fetchRegions(self.projectId).then((regions) => {\n        self.collections.regions = regions;\n        self.models.privateNetwork.regions = _.filter(regions, _.isString);\n      }).catch(() => {\n        self.collections.regions = [];\n      });\n    };\n\n    self.getRegions = function () {\n      return self.collections.regions;\n    };\n\n    self.hasRegion = function (region) {\n      return _.indexOf(self.collections.regions, region) !== -1;\n    };\n\n    self.toggleActiveRegion = function (region) {\n      if (!self.hasRegion(region)) {\n        return;\n      }\n\n      if (self.hasActiveRegion(region)) {\n        _.pull(self.models.privateNetwork.regions, region);\n      } else {\n        self.models.privateNetwork.regions.push(region);\n      }\n\n      self.presetNetwork();\n    };\n\n    self.hasActiveRegion = function (region) {\n      return _.indexOf(self.models.privateNetwork.regions, region) !== -1;\n    };\n\n    self.getActiveRegions = function () {\n      return self.models.privateNetwork.regions;\n    };\n\n    self.isRegionTogglingDisabled = function (region) {\n      return self.models.privateNetwork.regions.length <= 1 && self.hasActiveRegion(region);\n    };\n\n    self.getSubnetsDescription = function () {\n      return _.filter(this.models.privateNetwork.regions, _.isString).join(', ');\n    };\n\n    self.toggleEditDescription = function () {\n      self.states.description.edit = !self.states.description.edit;\n    };\n\n    self.hasErrors = function (ngModel) {\n      if (!ngModel) {\n        return false;\n      }\n\n      return ngModel.$invalid;\n    };\n\n    self.getGroupClasses = function (ngModel) {\n      if (!ngModel) {\n        return {};\n      }\n\n      return {\n        'has-success': ngModel.$touched && ngModel.$valid,\n        'has-error': self.hasErrors(ngModel),\n      };\n    };\n\n    self.getActivePage = function () {\n      return self.states.page;\n    };\n\n    self.getActivePageIndex = function () {\n      switch (self.states.page) {\n        case 'common':\n        case 'subnets': return 1;\n        default: return 0;\n      }\n    };\n\n    self.isActivePage = function (page) {\n      if (!self.states.page) {\n        return false;\n      }\n\n      return self.states.page === page;\n    };\n\n    self.setActivePage = function (page) {\n      self.states.page = page;\n    };\n\n    self.isSwitchMode = function () {\n      if (!self.states.switch) {\n        return false;\n      }\n\n      return self.states.switch.getDisplayMode() === 'switch';\n    };\n\n    self.submit = function () {\n      if (!self.form.$valid || self.service.isSavePending()) {\n        return;\n      }\n\n      const options = {\n        projectId: self.projectId,\n        privateNetwork: self.models.privateNetwork,\n        subnets: self.models.subnets,\n        isDHCPEnabled: self.isDHCPEnabled(),\n        globalNetwork: self.getGlobalNetwork(),\n      };\n\n      $rootScope.$emit('private-networks:create', options);\n    };\n\n    self.getApiUrl = function () {\n      return self.service.getUrls().api || '';\n    };\n\n    function resetSubnetAddress() {\n      self.models.subnet.address = '192.168.0.0';\n    }\n\n    function resetIpRanges() {\n      const regions = _.sortBy(self.getActiveRegions(), region => region);\n      const split = CloudProjectComputeInfrastructurePrivateNetworkDialogService.splitSubnetIpAddresses('255.255.255.0', self.models.subnet.address, regions.length);\n\n      if (split.isValid) {\n        const subnets = _.zipWith(regions, split.ipBlocks, (region, ipBlock) => {\n          _.set(ipBlock, 'region', region);\n          // API needs noGateway but it is more logical to match with checkbox value first\n          _.set(ipBlock, 'gateway', false);\n          _.set(ipBlock, 'noGateway', !ipBlock.gateway);\n          return ipBlock;\n        });\n        self.models.subnets = _.zipObject(regions, subnets);\n      } else {\n        self.models.subnets = [];\n      }\n    }\n\n    self.presetNetwork = function (id) {\n      if (id) {\n        resetSubnetAddress(id);\n      }\n      resetIpRanges();\n    };\n\n\n    self.hasPendingLoaders = function () {\n      return self.service.areRegionsLoading()\n        || self.service.arePrivateNetworksLoading()\n        || self.service.isSavePending();\n    };\n\n    self.hasUntaggedVlan = function (networks) {\n      return self.findVlanWithID(networks, 0);\n    };\n\n    self.getNextId = function (networks) {\n      for (let i = self.constraints.vlanId.min; i < self.constraints.vlanId.max; i += 1) {\n        const vlanExists = self.findVlanWithID(networks, i);\n        if (!vlanExists) {\n          return i;\n        }\n      }\n      return false;\n    };\n\n    self.findVlanWithID = function (networks, id) {\n      return _.findWhere(networks, { vlanId: id });\n    };\n\n    self.close = function () {\n      $rootScope.$emit('private-network-dialog:hide');\n    };\n\n    self.changeSubnets = function (region) {\n      self.models.subnets[region].noGateway = !self.models.subnets[region].gateway;\n    };\n\n    $scope.$watch(() => self.states.vlan, (newValue, oldValue) => {\n      if (oldValue !== newValue) {\n        if (newValue === true) {\n          self.models.privateNetwork.vlanId = self.userInput.vlanId;\n        } else {\n          self.userInput.vlanId = self.models.privateNetwork.vlanId;\n          self.models.privateNetwork.vlanId = 0;\n        }\n      }\n    });\n\n    $scope.$watch(() => self.models.privateNetwork.vlanId, (newValue, oldValue) => {\n      if (oldValue !== newValue) {\n        self.presetNetwork(newValue);\n      }\n    });\n\n    $scope.$watch('self.models.privateNetwork.vlanId', (newValue, oldValue) => {\n      if (oldValue !== newValue) {\n        self.presetNetwork(newValue);\n      }\n    });\n\n    init();\n  });\n"]}