{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/privateNetwork/dialog/cloud-project-compute-infrastructure-privateNetwork-dialog.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/privateNetwork/dialog/cloud-project-compute-infrastructure-privateNetwork-dialog.service.js","mtime":1539717142000},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["/* eslint-disable no-bitwise */\nclass CloudProjectComputeInfrastructurePrivateNetworkDialogService {\n  constructor($timeout, OvhApiCloudProjectNetworkPrivate,\n    CloudProjectComputeInfrastructurePrivateNetworkService) {\n    this.$timeout = $timeout;\n    this.OvhApiCloudProjectNetworkPrivate = OvhApiCloudProjectNetworkPrivate;\n    this.Service = CloudProjectComputeInfrastructurePrivateNetworkService;\n  }\n\n  fetchPrivateNetworks(serviceName) {\n    return this.Service.fetchPrivateNetworks(serviceName);\n  }\n\n  arePrivateNetworksLoading() {\n    return this.Service.arePrivateNetworksLoading();\n  }\n\n  fetchPrivateNetwork(serviceName, id) {\n    return this.Service.fetchPrivateNetwork(serviceName, id);\n  }\n\n  isPrivateNetworkLoading() {\n    return this.Service.isPrivateNetworkLoading();\n  }\n\n  fetchRegions(serviceName) {\n    return this.Service.fetchRegions(serviceName);\n  }\n\n    areRegionsLoading = function () {\n      return this.Service.areRegionsLoading();\n    }\n\n    fetchUrls() {\n      return this.Service.fetchUrls();\n    }\n\n    areUrlsLoading = function () {\n      return this.Service.areUrlsLoading();\n    }\n\n    getUrls = function () {\n      return this.Service.getUrls;\n    }\n\n    static isIPv4(address) {\n      return /^(\\d{1,3}\\.){3,3}\\d{1,3}$/.test(address);\n    }\n\n    savePrivateNetwork(projectId, privateNetwork, onSuccess) {\n      return this.Service.savePrivateNetwork(projectId, privateNetwork, onSuccess);\n    }\n\n    pollPrivateNetworkStatus(options, onSuccess, onFailure) {\n      this.$timeout(() => {\n        if (this.isPrivateNetworkLoading()) {\n          return;\n        }\n\n        this.OvhApiCloudProjectNetworkPrivate.v6().resetCache();\n\n        this.fetchPrivateNetwork(\n          options.serviceName,\n          options.privateNetworkId,\n        ).then((network) => {\n          if (this.areAllRegionsActive(network)) {\n            onSuccess(network, options);\n          } else {\n            this.pollPrivateNetworkStatus(options, onSuccess, onFailure);\n          }\n        }).catch(error => onFailure(error));\n      }, options.delay || 2000);\n    }\n\n    saveSubnet(projectId, networkId, subnet) {\n      return this.Service.saveSubnet(projectId, networkId, subnet);\n    }\n\n    isSavePending() {\n      return this.Service.isSavePending();\n    }\n\n    getConstraints() {\n      return this.Service.getConstraints();\n    }\n\n    areAllRegionsActive(network) {\n      return this.Service.areAllRegionsActive(network);\n    }\n\n    splitSubnetIpAddresses(networkMask, networkAddress, numberOfChunk) {\n      const splitData = this.getIpSplitData(networkMask, networkAddress, numberOfChunk);\n      const data = this.validateSplitData(splitData);\n\n      if (!data.isValid) {\n        return data;\n      }\n\n      const chunks = [];\n\n      // When incrementing the initialIp we always skip 1 IP that will act as the network address\n      // for the IPs block.\n      const ipBlockIncrement = 2;\n      let initialIp = splitData.hostAddressInteger + ipBlockIncrement;\n      for (let i = 0; i < numberOfChunk; i += 1) {\n        const start = initialIp;\n        let end = start + splitData.chunkSize - 1;\n\n        // If i is an uneven number, and if we have extras, we distribute one extra.\n        if (splitData.extras && i % 2 !== 1) {\n          end += 1;\n          splitData.extras -= 1;\n        }\n\n        chunks.push({\n          start: this.constructor.convertIpIntToIpString(start),\n          end: this.constructor.convertIpIntToIpString(end),\n          total: end - start + 1,\n        });\n\n        initialIp = end + ipBlockIncrement;\n      }\n\n      return {\n        isValid: true,\n        message: '',\n        ipBlocks: chunks,\n      };\n    }\n\n    getNthNetworkAddress(networkMask, networkAddress, n) {\n      const data = this.validateNetworkData(networkMask, networkAddress, n);\n      if (!data.isValid) {\n        return data;\n      }\n\n      const hostBitNumber = this.getNumberOfBitAllocatedToHost(networkMask);\n      const shift = hostBitNumber;\n      const shiftedHostAdressInteger = parseInt(\n        this.constructor.convertIpToByteString(networkAddress),\n        2,\n      ) >>> shift;\n\n      return {\n        isValid: true,\n        message: '',\n        address: this.constructor.convertIpIntToIpString((shiftedHostAdressInteger + n) << shift),\n      };\n    }\n\n    validateNetworkData(networkMask, networkAddress, n) {\n      let isValid = true;\n      let message = '';\n\n      if (this.isAdressPartOfSubnet(networkMask, networkAddress)) {\n        isValid = false;\n        message = `The provided network address (${networkAddress}) is not part of the subnet ${networkMask}.`;\n      } else if (n < 1) {\n        isValid = false;\n        message = `Number of chunk needs to be at least 1.  Provided: ${n}.`;\n      }\n\n      return {\n        isValid,\n        message,\n      };\n    }\n\n    getIpSplitData(networkMask, networkAddress, numberOfChunk) {\n      const hostAddressInteger = parseInt(\n        this.constructor.convertIpToByteString(networkAddress),\n        2,\n      );\n      const networkMaskInteger = parseInt(this.constructor.convertIpToByteString(networkMask), 2);\n\n      const lastHostBit = this.getNumberOfBitAllocatedToHost(networkMask, networkAddress);\n\n      // Number of total IPs for number of bit available - 1 IP for network address - 1 IP\n      // for broadcast address - numberOfChunk.\n      const numberOfUsableIps = Math.pow(2, lastHostBit) - 2 - numberOfChunk; // eslint-disable-line\n      const chunkSize = Math.floor(numberOfUsableIps / numberOfChunk);\n      const extras = numberOfUsableIps % numberOfChunk;\n\n      return {\n        networkMask,\n        networkAddress,\n        hostAddressInteger,\n        networkMaskInteger,\n        lastHostBit,\n        numberOfChunk,\n        chunkSize,\n        numberOfUsableIps,\n        extras,\n      };\n    }\n\n    validateSplitData(splitData) {\n      let isValid = true;\n      let message = '';\n\n      if (splitData.numberOfChunk <= 0) {\n        isValid = false;\n        message = `Number of chunk needs to be at least 1.  Provided: ${splitData.numberOfChunk}.`;\n      } else if (this.isAdressPartOfSubnet(splitData.networkMask, splitData.networkAddress)) {\n        isValid = false;\n        message = `The provided network address (${splitData.networkAddress}) is not part of the subnet ${splitData.networkMask}.`;\n      } else if (splitData.numberOfChunk > splitData.numberOfUsableIps) {\n        isValid = false;\n        message = `Too few possible addresses (${splitData.numberOfUsableIps}) for number of chunks (${splitData.numberOfChunk}).  At least 1 address is needed per chunk.`;\n      }\n\n      return {\n        isValid,\n        message,\n      };\n    }\n\n    isAdressPartOfSubnet(networkMask, networkAddress) {\n      const hostBitNumber = this.getNumberOfBitAllocatedToHost(networkMask);\n      const hostAddressInteger = parseInt(\n        this.constructor.convertIpToByteString(networkAddress),\n        2,\n      );\n      const networkMaskInteger = parseInt(this.constructor.convertIpToByteString(networkMask), 2);\n\n\n      const shiftedHostAdressInteger = hostAddressInteger >>> hostBitNumber;\n      const shiftedNoetworkMaskInteger = networkMaskInteger >>> hostBitNumber;\n\n      // Common way to see if an IP is part of a submask.\n      // submask & (bitwise and) ipAddress should equal ipAddress if the IP is part of the submask.\n      let bitWiseComparison = shiftedHostAdressInteger & shiftedNoetworkMaskInteger;\n      // If the result is a negative integer, we shift it to unsigned int.\n      bitWiseComparison = bitWiseComparison > 0 ? bitWiseComparison : bitWiseComparison >>> 0;\n\n      return bitWiseComparison !== shiftedHostAdressInteger;\n    }\n\n    static convertIpIntToIpString(int) {\n      const part1 = int & 255;\n      const part2 = ((int >> 8) & 255);\n      const part3 = ((int >> 16) & 255);\n      const part4 = ((int >> 24) & 255);\n\n      return `${part4}.${part3}.${part2}.${part1}`;\n    }\n\n    getNumberOfBitAllocatedToHost(networkMask, networkAddress) {\n      const lastHostMaskBit = this.constructor.convertIpToByteString(networkMask, true).indexOf(1);\n      if (!networkAddress) {\n        return lastHostMaskBit;\n      }\n\n      const hostAddressBytes = this.constructor.convertIpToByteString(networkAddress, true);\n      const lastHostAddressBit = hostAddressBytes.indexOf(1);\n\n      let lastHostBit = 0;\n      if (lastHostMaskBit > lastHostAddressBit) {\n        lastHostBit = lastHostAddressBit;\n      } else {\n        lastHostBit = lastHostMaskBit;\n      }\n\n      return lastHostBit;\n    }\n\n    static convertIpToByteString(ip, reverse) {\n      const ipParts = ip.split('.');\n      let byteString = '';\n      for (let i = 0; i < ipParts.length; i += 1) {\n        byteString += _.padLeft(parseInt(ipParts[i], 10).toString(2), 8, '0');\n      }\n\n      if (reverse) {\n        return byteString.split('').reverse().join('');\n      }\n      return byteString;\n    }\n}\n\nangular.module('managerApp').service('CloudProjectComputeInfrastructurePrivateNetworkDialogService',\n  CloudProjectComputeInfrastructurePrivateNetworkDialogService);\n/* eslint-enable no-bitwise */\n"]}