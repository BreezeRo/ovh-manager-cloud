{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/dbaas/logs/detail/inputs/logs-inputs.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/dbaas/logs/detail/inputs/logs-inputs.service.js","mtime":1539717142091},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["class LogsInputsService {\n  constructor($q, CloudMessage, CloudPoll, LogsHelperService, LogsConstants, LogsOptionsService,\n    OvhApiDbaas, ServiceHelper) {\n    this.$q = $q;\n    this.AccountingAapiService = OvhApiDbaas.Logs().Accounting().Aapi();\n    this.DetailsAapiService = OvhApiDbaas.Logs().Details().Aapi();\n    this.CloudMessage = CloudMessage;\n    this.CloudPoll = CloudPoll;\n    this.InputsApiAapiService = OvhApiDbaas.Logs().Input().Aapi();\n    this.InputsApiLexiService = OvhApiDbaas.Logs().Input().v6();\n    this.LogsConstants = LogsConstants;\n    this.LogsOptionsService = LogsOptionsService;\n    this.OperationApiService = OvhApiDbaas.Logs().Operation().v6();\n    this.ServiceHelper = ServiceHelper;\n    this.LogsHelperService = LogsHelperService;\n\n    this.initializeData();\n  }\n\n  initializeData() {\n    this.flowggerLogFormats = [\n      {\n        value: 'GELF',\n        name: 'inputs_logs_configure_format_gelf',\n      },\n      {\n        value: 'RFC5424',\n        name: 'inputs_logs_configure_format_rfc',\n      },\n      {\n        value: 'LTSV',\n        name: 'inputs_logs_configure_format_ltsv',\n      },\n      {\n        value: 'CAPNP',\n        name: 'inputs_logs_configure_format_cap_proto',\n      },\n    ];\n\n    this.delimiters = [\n      {\n        value: 'LINE',\n        name: 'inputs_logs_configure_delimiter_line',\n      },\n      {\n        value: 'NUL',\n        name: 'inputs_logs_configure_delimiter_nul',\n      },\n      {\n        value: 'SYSLEN',\n        name: 'inputs_logs_configure_delimiter_syslen',\n      },\n      {\n        value: 'CAPNP',\n        name: 'inputs_logs_configure_format_cap_proto',\n      },\n    ];\n\n    this.logstashLogFormats = [\n      {\n        value: 'Syslog',\n        name: 'inputs_logs_configure_format_syslog',\n      },\n      {\n        value: 'Apache',\n        name: 'inputs_logs_configure_format_apache',\n      },\n      {\n        value: 'HAProxy',\n        name: 'inputs_logs_configure_format_ha_proxy',\n      },\n      {\n        value: 'MySQL Slow Queries',\n        name: 'inputs_logs_configure_format_my_sql',\n      },\n      {\n        value: 'Twitter',\n        name: 'inputs_logs_configure_format_twitter',\n      },\n      {\n        value: 'Nginx',\n        name: 'inputs_logs_configure_format_nginx',\n      },\n    ];\n  }\n\n  getFlowggerLogFormats() {\n    return this.flowggerLogFormats;\n  }\n\n  getLogstashLogFormats() {\n    return this.logstashLogFormats;\n  }\n\n  getDelimiters() {\n    return this.delimiters;\n  }\n\n  /**\n   * add input\n   *\n   * @param {any} serviceName\n   * @param {any} input, input object to be added\n   * @returns promise which will resolve with the operation object\n   * @memberof LogsInputsService\n   */\n  addInput(serviceName, input) {\n    return this.InputsApiLexiService\n      .create({ serviceName }, this.constructor.transformInputToSave(input))\n      .$promise\n      .then((operation) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data);\n      })\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_add_error', err, { inputTitle: input.info.title }));\n  }\n\n  /**\n   * delete input\n   *\n   * @param {any} serviceName\n   * @param {any} input, input object to be deleted\n   * @returns promise which will resolve with the operation object\n   * @memberof LogsInputsService\n   */\n  deleteInput(serviceName, input) {\n    return this.InputsApiLexiService.delete({ serviceName, inputId: input.info.inputId })\n      .$promise\n      .then((operation) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation, 'logs_inputs_delete_success', { inputTitle: input.info.title });\n      })\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_delete_error', err, { inputTitle: input.info.title }));\n  }\n\n  /**\n   * returns array of Input IDs of logged in user\n   *\n   * @param {any} serviceName\n   * @returns promise which will be resolve to array of input IDs\n   * @memberof LogsInputsService\n   */\n  getDetails(serviceName) {\n    return this.DetailsAapiService.me({ serviceName })\n      .$promise.then(details => this.constructor.transformDetails(details))\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_details_get_error', err, {}));\n  }\n\n  /**\n   * returns array of Input IDs of logged in user\n   *\n   * @param {any} serviceName\n   * @returns promise which will be resolve to array of input IDs\n   * @memberof LogsInputsService\n   */\n  getAllInputs(serviceName) {\n    return this.InputsApiLexiService.query({ serviceName }).$promise;\n  }\n\n  /**\n   * returns details of an input\n   *\n   * @param {any} serviceName\n   * @param {any} inputId\n   * @returns promise which will be resolve to an input object\n   * @memberof LogsInputsService\n   */\n  getInput(serviceName, inputId) {\n    return this.InputsApiAapiService.get({ serviceName, inputId })\n      .$promise.catch(err => this.LogsHelperService.handleError('logs_inputs_get_error', err, {}));\n  }\n\n  /**\n   * returns details of an input and transforms it\n   *\n   * @param {any} serviceName\n   * @param {any} inputId\n   * @returns promise which will be resolve to an input object\n   * @memberof LogsInputsService\n   */\n  getInputDetail(serviceName, inputId) {\n    return this.getInput(serviceName, inputId)\n      .then(input => this.transformInput(input));\n  }\n\n  /**\n   * gets a temporary url to retrive the input logs\n   *\n   * @param {any} serviceName\n   * @param {any} inputId\n   * @returns promise which will resolve with the temporary url\n   * @memberof LogsInputsService\n   */\n  getInputLogUrl(serviceName, inputId) {\n    return this.InputsApiLexiService.logurl({ serviceName, inputId })\n      .$promise.catch(err => this.LogsHelperService.handleError('logs_inputs_logurl_error', err, {}));\n  }\n\n  /**\n   * gets details of all inputs\n   *\n   * @param {any} serviceName\n   * @returns promise which will be resolve to an array of inputs\n   * @memberof LogsInputsService\n   */\n  getInputs(serviceName) {\n    return this.getAllInputs(serviceName)\n      .then((inputIds) => {\n        const promises = inputIds.map(inputId => this.getInputDetail(serviceName, inputId));\n        return this.$q.all(promises);\n      });\n  }\n\n  getMainOffer(serviceName) {\n    return this.AccountingAapiService.me({ serviceName }).$promise\n      .then(me => ({\n        max: me.offer.maxNbInput,\n        current: me.offer.curNbInput,\n      })).catch(err => this.LogsHelperService.handleError('logs_inputs_main_offer_get_error', err, {}));\n  }\n\n  getNewInput() {\n    return {\n      data: {\n        info: {\n          exposedPort: this.LogsConstants.INPUT_DEFAULT_PORT,\n        },\n      },\n      loading: false,\n    };\n  }\n\n  /**\n   * returns the object containing total number of inputs and total number of inputs used\n   *\n   * @param {any} serviceName\n   * @returns quota object containing total number inputs and configured number of inputs\n   * @memberof LogsInputsService\n   */\n  getQuota(serviceName) {\n    return this.AccountingAapiService.me({ serviceName }).$promise\n      .then((me) => {\n        const quota = {\n          max: me.total.maxNbInput,\n          configured: me.total.curNbInput,\n          currentUsage: me.total.curNbInput * 100 / me.total.maxNbInput,\n        };\n        return quota;\n      }).catch(err => this.LogsHelperService.handleError('logs_inputs_quota_get_error', err, {}));\n  }\n\n  /**\n   * returns the subscribed options\n   *\n   * @param {any} serviceName\n   * @returns array of options\n   * @memberof LogsInputsService\n   */\n  getSubscribedOptions(serviceName) {\n    return this.LogsOptionsService.getSubscribedOptionsByType(\n      serviceName,\n      this.LogsConstants.INPUT_OPTION_REFERENCE,\n    );\n  }\n\n  /**\n   * restart an input\n   *\n   * @param {any} serviceName\n   * @param {any} inputId\n   * @returns promise which will resolve with the operation object\n   * @memberof LogsInputsService\n   */\n  restartInput(serviceName, input) {\n    return this.InputsApiLexiService.restart({ serviceName, inputId: input.info.inputId })\n      .$promise\n      .then((operation) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation, 'logs_inputs_restart_success', { inputTitle: input.info.title });\n      })\n      .catch((err) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleError('logs_inputs_restart_error', err, { inputTitle: input.info.title });\n      });\n  }\n\n  /**\n   * start an input\n   *\n   * @param {any} serviceName\n   * @param {any} inputId\n   * @returns promise which will resolve with the operation object\n   * @memberof LogsInputsService\n   */\n  startInput(serviceName, input) {\n    return this.InputsApiLexiService.start({ serviceName, inputId: input.info.inputId })\n      .$promise\n      .then((operation) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation, 'logs_inputs_start_success', { inputTitle: input.info.title });\n      })\n      .catch((err) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleError('logs_inputs_start_error', err, { inputTitle: input.info.title });\n      });\n  }\n\n  /**\n   * stop an input\n   *\n   * @param {any} serviceName\n   * @param {any} inputId\n   * @returns promise which will resolve with the operation object\n   * @memberof LogsInputsService\n   */\n  stopInput(serviceName, input) {\n    return this.InputsApiLexiService.end({ serviceName, inputId: input.info.inputId })\n      .$promise\n      .then((operation) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation, 'logs_inputs_stop_success', { inputTitle: input.info.title });\n      })\n      .catch((err) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleError('logs_inputs_stop_error', err, { inputTitle: input.info.title });\n      });\n  }\n\n  /**\n   * transforms the input by adding some additional information\n   *\n   * @param {any} input\n   * @returns the transformed input\n   * @memberof LogsInputsService\n   */\n  transformInput(input) {\n    _.set(input, 'info.engine.software', [input.info.engine.name, input.info.engine.version].join(' '));\n    _.set(input, 'info.exposedPort', parseInt(input.info.exposedPort, 10));\n    _.set(input, 'actionsMap', input.actions.reduce((actions, action) => {\n      actions[action.type] = action.isAllowed; // eslint-disable-line\n      return actions;\n    }, {}));\n\n    const isProcessing = input.info.status === this.LogsConstants.inputStatus.PROCESSING;\n    const isToBeConfigured = input.info.status === this.LogsConstants.inputStatus.INIT\n      && !input.actionsMap.START;\n    const isPending = (input.info.status === this.LogsConstants.inputStatus.INIT\n      || input.info.status === this.LogsConstants.inputStatus.PENDING)\n      && input.actionsMap.START;\n    const isRunning = input.info.status === this.LogsConstants.inputStatus.RUNNING;\n\n    /* eslint-disable no-nested-ternary */\n    _.set(input, 'info.state', isProcessing ? this.LogsConstants.inputState.PROCESSING\n      : input.info.isRestartRequired ? this.LogsConstants.inputState.RESTART_REQUIRED\n        : isToBeConfigured ? this.LogsConstants.inputState.TO_CONFIGURE\n          : isPending ? this.LogsConstants.inputState.PENDING\n            : isRunning ? this.LogsConstants.inputState.RUNNING\n              : this.LogsConstants.inputState.UNKNOWN);\n    /* eslint-disable no-nested-ternary */\n    _.set(input, 'info.stateType', this.LogsConstants.inputStateType[input.info.state]);\n    return input;\n  }\n\n  addNetwork(serviceName, input, network) {\n    return this.InputsApiLexiService\n      .trustNetwork({ serviceName, inputId: input.info.inputId }, network)\n      .$promise\n      .then((operation) => {\n        this.InputsApiAapiService.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation);\n      })\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_network_add_error', err, { network: network.network, inputTitle: input.info.title }));\n  }\n\n  executeTest(serviceName, input) {\n    return this.InputsApiLexiService.test({ serviceName, inputId: input.info.inputId })\n      .$promise\n      .then(operation => this.LogsHelperService.handleOperation(serviceName, operation))\n      .then(() => this.getTestResults(serviceName, input))\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_test_error', err, { inputTitle: input.info.title }));\n  }\n\n  removeNetwork(serviceName, input, network) {\n    return this.InputsApiLexiService\n      .rejectNetwork({\n        serviceName,\n        inputId: input.info.inputId,\n        allowedNetworkId: network.allowedNetworkId,\n      })\n      .$promise\n      .then((operation) => {\n        this.InputsApiAapiService.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation);\n      })\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_network_remove_error', err, { network: network.network, inputTitle: input.info.title }));\n  }\n\n  updateFlowgger(serviceName, input, flowgger) {\n    return this.InputsApiLexiService\n      .updateFlowgger({ serviceName, inputId: input.info.inputId }, flowgger)\n      .$promise\n      .then((operation) => {\n        this.InputsApiAapiService.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation);\n      })\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_flowgger_update_error', err, { inputTitle: input.info.title }));\n  }\n\n  updateLogstash(serviceName, input, logstash) {\n    return this.InputsApiLexiService\n      .updateLogstash({ serviceName, inputId: input.info.inputId }, logstash)\n      .$promise\n      .then((operation) => {\n        this.InputsApiAapiService.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation);\n      })\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_logstash_update_error', err, { inputTitle: input.info.title }));\n  }\n\n  /**\n   * update input\n   *\n   * @param {any} serviceName\n   * @param {any} input, input object to be updated\n   * @returns promise which will resolve with the operation object\n   * @memberof LogsInputsService\n   */\n  updateInput(serviceName, input) {\n    return this.InputsApiLexiService\n      .update({\n        serviceName,\n        inputId: input.info.inputId,\n      }, this.constructor.transformInputToSave(input))\n      .$promise\n      .then((operation) => {\n        this.resetAllCache();\n        return this.LogsHelperService.handleOperation(serviceName, operation.data || operation);\n      })\n      .catch(err => this.LogsHelperService.handleError('logs_inputs_update_error', err, { inputTitle: input.info.title }));\n  }\n\n  getTestResults(serviceName, input) {\n    return this.InputsApiLexiService.testResult({\n      serviceName,\n      inputId: input.info.inputId,\n    }).$promise;\n  }\n\n  /**\n   * Resets the cache of all APIs used\n   *\n   * @memberof LogsInputsService\n   */\n  resetAllCache() {\n    this.InputsApiAapiService.resetAllCache();\n    this.InputsApiLexiService.resetAllCache();\n    this.AccountingAapiService.resetAllCache();\n  }\n\n  static transformDetails(details) {\n    details.engines.forEach((engine) => {\n      if (!engine.isDeprecated) {\n        _.set(engine, 'name', engine.name.charAt(0).toUpperCase() + engine.name.toLowerCase().slice(1));\n      }\n    });\n    return details;\n  }\n\n  static transformInputToSave(input) {\n    return {\n      title: input.info.title,\n      description: input.info.description,\n      engineId: input.info.engineId,\n      optionId: input.info.optionId ? input.info.optionId : undefined,\n      streamId: input.info.streamId,\n      singleInstanceEnabled: input.info.singleInstanceEnabled,\n      exposedPort: input.info.exposedPort.toString(),\n    };\n  }\n}\n\nangular.module('managerApp').service('LogsInputsService', LogsInputsService);\n"]}