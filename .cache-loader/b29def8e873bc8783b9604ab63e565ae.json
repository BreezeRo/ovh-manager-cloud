{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/veeam/veeam.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/veeam/veeam.service.js","mtime":1539717142285},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["(() => {\n  const taskMessages = {\n    updateRepositoryQuota: 'veeam_storage_update_quota_',\n    addBackupRepositoryToCloudTenant: 'veeam_add_repository_',\n  };\n\n  class VeeamService {\n    constructor($interval, $q, $timeout, $translate, $filter, OvhApiVeeam, RegionService) {\n      this.$interval = $interval;\n      this.$q = $q;\n      this.$timeout = $timeout;\n      this.$translate = $translate;\n      this.$filter = $filter;\n      this.veeam = OvhApiVeeam.v6();\n      this.RegionService = RegionService;\n\n      this.unitOfWork = { };\n      this.unitOfWork.init = () => {\n        this.unitOfWork.messages = [];\n        this.unitOfWork.tasks = [];\n        this.unitOfWork.doneTasks = [];\n        this.unitOfWork.errorTasks = [];\n        this.startPolling();\n      };\n\n      this.pollingDeferred = {};\n    }\n\n    getConfigurationInfos(serviceName) {\n      return this.$q.all({\n        detail: this.veeam.getDetails({\n          serviceName,\n        }).$promise,\n        inventoryNames: this.veeam.getInventories({\n          serviceName,\n        }).$promise,\n      })\n        .then(response => this.acceptResponse(this.transformConfigurationInfos(response)))\n        .catch(response => this.rejectResponse(response, this.$translate.instant('veeam_infos_configuration_load_error')));\n    }\n\n    transformConfigurationInfos(infos) {\n      _.set(infos, 'detail.location', this.RegionService.getRegion(infos.detail.location));\n      _.set(infos, 'detail.backupCount', infos.inventoryNames.length);\n      return infos.detail;\n    }\n\n    getStorages(serviceName) {\n      return this.veeam.getInventories({\n        serviceName,\n      }).$promise.then((storages) => {\n        const storagesPromises = storages\n          .map(storage => this.getStorageDetails(serviceName, storage));\n        return this.$q.all(storagesPromises);\n      })\n        .then(response => this.acceptResponse(response))\n        .catch(response => this.rejectResponse(response.data, this.$translate.instant('veeam_storage_list_load_error')));\n    }\n\n    getStorageDetails(serviceName, inventoryName) {\n      return this.veeam.getInventory({\n        serviceName,\n        inventoryName,\n      }).$promise;\n    }\n\n    getSubscriptionInfos(serviceName) {\n      return this.$q.all({\n        details: this.veeam.getDetails({ serviceName }).$promise,\n        serviceInfo: this.veeam.getServiceInfos({ serviceName }).$promise,\n      })\n        .then(response => this.acceptResponse(this.transformSubscriptionInfos(response)))\n        .catch(response => this.rejectResponse(response.data, this.$translate.instant('veeam_infos_subscription_load_error')));\n    }\n\n    transformSubscriptionInfos(data) {\n      const renewalType = data.serviceInfo.renew.automatic === true ? 'automatic' : 'manual';\n      _.set(data, 'serviceInfo.offer', data.details.productOffer);\n      _.set(data, 'serviceInfo.renewalType', renewalType);\n      _.set(data, 'serviceInfo.renewalTypeDescription', this.$translate.instant(`veeam_infos_subscription_renew_${renewalType}_description`));\n      _.set(data, 'serviceInfo.isOnTrial', data.serviceInfo.offer === 'demo');\n      _.set(data, 'serviceInfo.subscriptionTimeRemaining', (moment(data.serviceInfo.expiration)).diff(moment(), 'days'));\n\n      return data.serviceInfo;\n    }\n\n    getOrderableOffers(serviceName) {\n      return this.veeam.getOrderableOffers({\n        serviceName,\n      }).$promise\n        .then(response => this.acceptResponse(response))\n        .catch(response => this.rejectResponse(response, this.$translate.instant('veeam_orderable_offer_load_error')));\n    }\n\n    getOrderableOfferPrices(serviceName) {\n      return this.veeam.getOrderableOffers({\n        serviceName,\n      }).$promise\n        .then((offers) => {\n          const promises = _.map(offers, offer => this.getUpgradeOptionDurations(serviceName, offer)\n            .then(durations => _.map(durations.data, duration => ({ offer, duration }))));\n          return this.$q.all(promises).then(durations => _.flatten(durations));\n        })\n        .then((durations) => {\n          const promises = _.map(\n            durations,\n            duration => this.getUpgradeOptionPrices(serviceName, duration.offer, duration.duration)\n              .then(price => ({\n                offer: duration.offer,\n                duration: duration.duration,\n                price: price.data,\n              })),\n          );\n          return this.$q.all(promises);\n        })\n        .then(response => this.acceptResponse(response))\n        .catch(response => this.rejectResponse(response, this.$translate.instant('veeam_orderable_offer_load_error')));\n    }\n\n    getUpgradeOptionDurations(serviceName, offer) {\n      return this.veeam.getOrderUpgradeDurations({\n        serviceName,\n        offer,\n      }).$promise\n        .then(response => this.acceptResponse(response))\n        .catch(response => this.rejectResponse(response));\n    }\n\n    getUpgradeOptionPrices(serviceName, offer, duration) {\n      return this.veeam.getOrderUpgradeDurationsPrices({\n        serviceName,\n        duration,\n        offer,\n      }).$promise\n        .then(response => this.acceptResponse(response))\n        .catch(response => this.rejectResponse(response));\n    }\n\n    updateOffer(serviceName, offer, duration) {\n      return this.veeam.createUpgradeOrder({\n        serviceName,\n        duration,\n      }, {\n        offer,\n      }).$promise\n        .then(response => this.acceptResponse(response, this.$translate.instant('veeam_update_offer_post_success', { orderId: response.orderId, orderUrl: response.url })))\n        .catch(response => this.rejectResponse(response, this.$translate.instant('veeam_update_offer_post_error')));\n    }\n\n    addBackupRepository(serviceName) {\n      return this.veeam.addInventory({\n        serviceName,\n      }, {}).$promise\n        .then(response => this.acceptResponse(response, this.$translate.instant('veeam_add_repository_success')))\n        .catch(response => this.rejectResponse(response, this.$translate.instant('veeam_add_repository_error')));\n    }\n\n    updateRepositoryQuota(serviceName, inventoryName, newQuota) {\n      return this.veeam.upgradeQuota({\n        serviceName,\n        inventoryName,\n      }, {\n        newQuota,\n      }).$promise\n        .then(response => this.acceptResponse(response, this.$translate.instant('veeam_storage_update_quota_success')))\n        .catch(response => this.rejectResponse(response, this.$translate.instant('veeam_storage_update_quota_error')));\n    }\n\n    getCapabilities(serviceName) {\n      return this.veeam.capabilities({\n        serviceName,\n      }).$promise;\n    }\n\n    getActions(serviceName) {\n      return this.$q.all({\n        storages: this.getStorages(serviceName),\n        capabilities: this.getCapabilities(serviceName),\n        subcription: this.getSubscriptionInfos(serviceName),\n      }).then((results) => {\n        const storages = results.storages.data;\n        const { capabilities } = results;\n        const subscription = results.subcription.data;\n\n        const addStorage = {\n          available: true,\n        };\n\n        if (!capabilities.multiStorages) {\n          addStorage.available = false;\n          addStorage.reason = this.$translate.instant('veeam_action_add_storage_unavailable_offer', { offer: subscription.offer });\n        } else if (storages.length >= capabilities.maxStoragesCount) {\n          addStorage.available = false;\n          addStorage.reason = this.$translate.instant('veeam_action_add_storage_unavailable_storage_number');\n        } else if (this.calculateUsage(storages) < capabilities.minimumUsage) {\n          addStorage.available = false;\n          addStorage.reason = this.$translate.instant('veeam_action_add_storage_unavailable_usage_percentage', { usagePercentage: capabilities.minimumUsage });\n        }\n\n        return this.acceptResponse({\n          addStorage,\n          manageBilling: {\n            available: true,\n          },\n          upgradeOffer: {\n            available: subscription.isOnTrial,\n            reason: !subscription.isOnTrial ? this.$translate.instant('veeam_action_upgrade_offer_no_upgrade', { offer: subscription.offer }) : '',\n          },\n        });\n      });\n    }\n\n    calculateUsage(storages) {\n      const usage = _.chain(storages)\n        .map((storage) => {\n          if (storage.quotaUsed && storage.quotaUsed.value && storage.quotaUsed.unit) {\n            return this.$filter('bytes')(storage.quotaUsed.value, 0, false, storage.quotaUsed.unit, true);\n          }\n          return 0;\n        })\n        .sum()\n        .value();\n      const available = _.chain(storages)\n        .map(storage => this.$filter('bytes')(storage.quota.value, 0, false, storage.quota.unit, true))\n        .sum()\n        .value();\n      return 100 * usage / available;\n    }\n\n    getTasks(serviceName, options) {\n      return this.veeam.tasks(Object.assign({\n        serviceName,\n      }, options)).$promise\n        .then((tasks) => {\n          const promises = _.map(tasks, task => this.veeam.task({\n            serviceName,\n            taskId: task,\n          }).$promise);\n          return this.$q.all(promises);\n        });\n    }\n\n    getTask(serviceName, taskId) {\n      return this.veeam.task({\n        serviceName,\n        taskId,\n      }).$promise;\n    }\n\n    startPolling(serviceName, task) {\n      const poll = () => {\n        this.poller = this.$timeout();\n        if (this.isPolling) {\n          this.poller = this.$timeout(poll, 5000);\n          return null;\n        }\n        this.isPolling = true;\n        return this.$q.all([\n          this.getTasks(serviceName, { state: 'doing' }),\n          this.getTasks(serviceName, { state: 'todo' }),\n        ])\n          .then(result => _.flatten(result))\n          .then((tasks) => {\n            this.checkTasks(serviceName, tasks);\n          })\n          .catch(() => {\n            this.stopPolling();\n            // TODO: Post message to notify this error.\n          })\n          .finally(() => {\n            this.isPolling = false;\n            if (this.unitOfWork.tasks.length) {\n              this.poller = this.$timeout(poll, 5000);\n            }\n          });\n      };\n\n      if (!this.poller) {\n        this.$timeout(poll, 0);\n      }\n\n      if (task) {\n        // Add this new task to pending tasks\n        this.unitOfWork.tasks.push(task);\n        this.pollingDeferred[task.taskId] = this.$q.defer();\n        return this.pollingDeferred[task.taskId].promise;\n      }\n\n      return this.$q.resolve();\n    }\n\n    stopPolling() {\n      if (this.poller) {\n        this.$timeout.cancel(this.poller);\n        this.poller = undefined;\n        this.pollingDeferred = [];\n      }\n    }\n\n    getPendingTasksMessages() {\n      let messagesByTaskName = _.groupBy(_.uniq(this.unitOfWork.tasks, 'taskId'), 'name');\n      messagesByTaskName = _.forEach(messagesByTaskName, (task, taskName) => {\n        const taskMessage = taskMessages[taskName];\n\n        // We only watch some tasks.\n        if (taskMessage) {\n          messagesByTaskName[taskName] = {\n            message: this.$translate.instant(`${taskMessage}pending`),\n            task,\n          };\n        }\n      });\n      return messagesByTaskName;\n    }\n\n    checkTasks(serviceName, tasks) {\n      const oldTasksIds = _.map(this.unitOfWork.tasks, 'taskId');\n      const tasksIds = _.map(tasks, 'taskId');\n      const completedTasksIds = _.difference(oldTasksIds, tasksIds);\n      if (completedTasksIds.length) {\n        const completedTasks = this.unitOfWork.tasks\n          .filter(task => completedTasksIds.indexOf(task.taskId) >= 0);\n        this.$q.all(completedTasks.map((task) => {\n          const deferred = this.pollingDeferred[task.taskId];\n          return this.getTask(serviceName, task.taskId).then((completedTask) => {\n            if (completedTask.state === 'done') {\n              this.unitOfWork.doneTasks.push(completedTask);\n              if (deferred) {\n                deferred.resolve(completedTask);\n                this.unitOfWork.messages.push({\n                  text: this.$translate.instant(`${taskMessages[task.name]}success`),\n                  type: 'success',\n                });\n              }\n            } else if (completedTask.state === 'todo' || completedTask.state === 'doing') {\n              // Task is finally not done...\n              tasks.push(completedTask);\n            } else {\n              this.unitOfWork.errorTasks.push(completedTask);\n              if (deferred) {\n                deferred.reject(completedTask);\n                this.unitOfWork.messages.push({\n                  text: this.$translate.instant(`${taskMessages[task.name]}error`),\n                  type: 'error',\n                });\n              }\n            }\n          });\n        })).then(() => {\n          this.unitOfWork.tasks = _.filter(\n            tasks,\n            task => _.indexOf(_.keys(taskMessages), task.name) >= 0,\n          );\n          if (!this.unitOfWork.tasks.length) {\n            this.stopPolling();\n          }\n        });\n      }\n    }\n\n    acceptResponse(data, message) {\n      return this.$q.resolve({\n        status: 'OK',\n        data,\n        message,\n      });\n    }\n\n    rejectResponse(data, message) {\n      return this.$q.reject({\n        status: 'ERROR',\n        data,\n        message,\n      });\n    }\n  }\n\n  angular.module('managerApp').service('VeeamService', VeeamService);\n})();\n"]}