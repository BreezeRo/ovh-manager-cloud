{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/infrastructure/infrastructure-orchestrator.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/infrastructure/infrastructure-orchestrator.service.js","mtime":1539717374669},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["/**\n *  Cloud Infrastructure Orchestrator. Beyond it's the sun!\n *  =======================================================\n *\n *  =README=\n *  This orchestrator is used to init and manage a Cloud infrastructure.\n */\nangular.module('managerApp').service('CloudProjectComputeInfrastructureOrchestrator', [\"$q\", \"$translate\", \"$rootScope\", \"$timeout\", \"CLOUD_INSTANCE_DEFAULTS\", \"Poller\", \"CloudUserPref\", \"CloudProjectComputeVolumesOrchestrator\", \"CloudProjectComputeInfrastructureFactory\", \"OvhApiCloudProjectInstance\", \"OvhApiCloudProjectIp\", \"OvhApiIp\", \"OvhApiCloudProjectRegion\", \"OvhApiCloudProjectFlavor\", \"OvhApiCloudProjectImage\", \"OvhApiCloudProjectSshKey\", function ($q, $translate, $rootScope, $timeout, CLOUD_INSTANCE_DEFAULTS, Poller, CloudUserPref, CloudProjectComputeVolumesOrchestrator, CloudProjectComputeInfrastructureFactory, OvhApiCloudProjectInstance, OvhApiCloudProjectIp, OvhApiIp, OvhApiCloudProjectRegion, OvhApiCloudProjectFlavor, OvhApiCloudProjectImage, OvhApiCloudProjectSshKey) {\n  // Warning: all values must be reset at init (see resetDatas())\n  var self = this;\n  var editedVm;\n  var monitoredVm;\n  var paramEdition = null; // type enum {NAME, POWER, OS}\n\n  var resetDatas = function resetDatas() {\n    // The full infra to display\n    self.infra = null; // Project type (existing, template, template-new)\n\n    self.serviceType = null; // Current edited VM\n\n    editedVm = null;\n    monitoredVm = null; // Stop polling if launched\n\n    self.killPollVms();\n    self.killPollIps();\n  };\n  /*= =========================\n  =            VMs           =\n  ========================== */\n\n  /**\n   * Get the default vm configuration for a specified region\n   */\n\n\n  function getDefaultVmConfigurationForRegion(defaultRegion) {\n    var options = {\n      name: $translate.instant('cpci_vm_default_name', {\n        index: self.infra.vrack.getNextIndex() + 1\n      }),\n      region: defaultRegion\n    };\n    var optionsQueue = []; // get the flavor id\n\n    optionsQueue.push(OvhApiCloudProjectFlavor.v6().query({\n      serviceName: self.infra.serviceName\n    }).$promise.then(function (flavors) {\n      _.set(options, 'flavorId', (_.find(flavors, {\n        region: options.region,\n        name: CLOUD_INSTANCE_DEFAULTS.flavor\n      }) || {}).id);\n    })); // get the image id\n\n    optionsQueue.push(OvhApiCloudProjectImage.v6().query({\n      serviceName: self.infra.serviceName\n    }).$promise.then(function (images) {\n      _.set(options, 'imageId', (_.find(images, {\n        region: options.region,\n        name: CLOUD_INSTANCE_DEFAULTS.image\n      }) || {}).id);\n    })); // get the ssh key id - the first ssh key present in given region\n    // remove this if default image becomes windows type\n\n    optionsQueue.push(OvhApiCloudProjectSshKey.v6().query({\n      serviceName: self.infra.serviceName\n    }).$promise.then(function (sshKeys) {\n      _.set(options, 'sshKeyId', (_.find(sshKeys, function (sshKey) {\n        return sshKey.regions.indexOf(options.region) > -1;\n      }) || {}).id);\n    }));\n    return $q.allSettled(optionsQueue).then(function () {\n      if (self.infra.vrack.publicCloud && self.infra.vrack.publicCloud.length() > 0) {\n        // use the most recent virtual machine parameters\n        var mostRecentVm = _.last(_.sortBy(self.infra.vrack.publicCloud.items, 'created'));\n\n        if (mostRecentVm) {\n          if (mostRecentVm.image) {\n            options.imageId = mostRecentVm.image.id;\n          }\n\n          if (mostRecentVm.flavor) {\n            options.flavorId = mostRecentVm.flavor.id;\n            options.isFlavorSuggested = true;\n          }\n\n          if (mostRecentVm.region) {\n            options.region = mostRecentVm.region;\n          }\n\n          if (mostRecentVm.sshKey) {\n            options.sshKeyId = mostRecentVm.sshKey.id;\n          }\n\n          options.monthlyBillingBoolean = mostRecentVm.monthlyBillingBoolean;\n        }\n      }\n\n      return options;\n    }, function () {\n      return options;\n    });\n  }\n  /**\n   *  Get the default vm configuration options\n   */\n\n\n  var getDefaultVmConfiguration = function getDefaultVmConfiguration() {\n    return OvhApiCloudProjectRegion.v6().query({\n      serviceName: self.infra.serviceName\n    }).$promise.then(function (regionList) {\n      // check if the default region exists\n      var region = CLOUD_INSTANCE_DEFAULTS.region;\n\n      if (_.indexOf(regionList, region) === -1) {\n        region = _.first(regionList);\n      }\n\n      return getDefaultVmConfigurationForRegion(region);\n    });\n  };\n  /**\n   *  Add a virtual machine into project infrastructure\n   */\n\n\n  this.addNewVmToList = function (vmOptions) {\n    var vm;\n    return $q.when(true).then(function () {\n      if (!vmOptions) {\n        return getDefaultVmConfiguration();\n      }\n\n      return vmOptions;\n    }).then(function (options) {\n      // Add Draft VM to list\n      vm = self.infra.vrack.addVmToPublicCloudList(options);\n      vm.status = 'DRAFT';\n      self.saveToUserPref();\n      return vm;\n    });\n  };\n  /**\n   *  Launch the vm creation.\n   */\n\n\n  this.saveNewVm = function (vm) {\n    var oldId = vm.id;\n    return vm.launchCreation().then(function () {\n      // we must do it because old id is a fake one\n      self.infra.vrack.publicCloud.replaceItem(oldId, vm);\n      self.saveToUserPref();\n      self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   * Launch vm creation, creating multiple copies.\n   */\n\n\n  this.saveMultipleNewVms = function (vmBase, count) {\n    return OvhApiCloudProjectInstance.v6().bulk({\n      serviceName: self.infra.serviceName\n    }, {\n      flavorId: vmBase.flavor.id,\n      imageId: vmBase.image.id,\n      name: vmBase.name,\n      region: vmBase.region,\n      sshKeyId: vmBase.sshKey ? vmBase.sshKey.id : undefined,\n      monthlyBilling: vmBase.monthlyBillingBoolean,\n      userData: vmBase.userData ? vmBase.userData : undefined,\n      number: count,\n      networks: vmBase.networks\n    }).$promise.then(function (vms) {\n      self.infra.vrack.publicCloud.removeItem(vmBase.id); // remove draft vm\n\n      self.pollVms(); // updates vm list\n\n      return vms;\n    });\n  };\n  /**\n   *  Set the virtual machine that is currently in edition\n   */\n\n\n  this.turnOnVmEdition = function (vm) {\n    editedVm = vm;\n    editedVm.startEdition();\n  };\n  /**\n   *  Close/Reset the virtual machine that is currently in edition\n   */\n\n\n  this.turnOffVmEdition = function (reset, vmWithChanges) {\n    editedVm.stopEdition(!!reset, vmWithChanges);\n    editedVm = null;\n  };\n  /**\n   *  Open monitoring panel\n   */\n\n\n  this.openMonitoringPanel = function (vm) {\n    monitoredVm = vm;\n    vm.startMonitoring();\n  };\n\n  this.getMonitoredVm = function () {\n    return monitoredVm;\n  };\n  /**\n   *  Get the virtual machine that is currently in edition\n   */\n\n\n  this.getEditedVm = function () {\n    return editedVm;\n  };\n  /**\n   *  Get parameters for current edition\n   */\n\n\n  this.getEditVmParam = function () {\n    return paramEdition;\n  };\n  /**\n   *  Get parameters for current edition\n   */\n\n\n  this.setEditVmParam = function (param) {\n    paramEdition = param;\n  };\n  /**\n   *  Save the VM modifications\n   */\n\n\n  this.saveEditedVm = function (vm) {\n    return vm.edit().then(function () {\n      self.saveToUserPref();\n      self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   *  Delete VM\n   */\n\n\n  this.deleteVm = function (vm) {\n    if (vm.status === 'DRAFT') {\n      return $q.when(true).then(function () {\n        self.infra.vrack.removeVmFromPublicCloudList(vm);\n        self.refreshLinks();\n        self.saveToUserPref();\n      });\n    }\n\n    return vm.remove().then(function () {\n      self.saveToUserPref();\n      self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   *  Rescue VM\n   */\n\n\n  this.rescueVm = function (vm, enable, image) {\n    return vm.rescueMode(enable, image).then(function (result) {\n      self.pollVms();\n      return result;\n    });\n  };\n  /**\n   *  Reboot [soft|hard] VM\n   */\n\n\n  this.rebootVm = function (vm, type) {\n    return vm.reboot(type).then(function () {\n      self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   *  Resume VM\n   */\n\n\n  this.resumeVm = function (vm) {\n    return vm.resume().then(function () {\n      self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   *  Reinstall VM\n   */\n\n\n  this.reinstallVm = function (vm) {\n    return vm.reinstall().then(function () {\n      self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   *  Create a new snapshot of VM\n   */\n\n\n  this.backupVm = function (vm, snapshotName) {\n    return vm.backup(snapshotName).then(function () {\n      self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n    });\n  };\n  /**\n   *  Collapse all vm\n   */\n\n\n  this.collapseAllVm = function () {\n    this.infra.vrack.collapseAll();\n    this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n  };\n  /**\n   *  Uncollapse all vm\n   */\n\n\n  this.uncollapseAllVm = function () {\n    this.infra.vrack.uncollapseAll();\n    this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n  };\n  /**\n   *  Toggle the collapsed state of given vm and save to userPref\n   */\n\n\n  this.toggleVmCollapsedState = function (vm) {\n    _.set(vm, 'collapsed', !vm.collapsed);\n\n    this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n\n    return $q.when(vm);\n  };\n  /**\n   *  Toggle the collapsed state of given vm and save to userPref\n   */\n\n\n  this.toggleCollapsedVolumes = function (vm) {\n    _.set(vm, 'collapsedVolumes', !vm.collapsedVolumes);\n\n    this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n\n    return $q.when(vm);\n  };\n\n  this.loadVmMonitoringData = function () {\n    _.each(this.infra.vrack.publicCloud.items, function (instance) {\n      instance.getMonitoringData();\n    });\n  };\n  /* -----  End of VMs  ------*/\n\n  /*= =========================\n   =         VLANs           =\n   ========================== */\n\n\n  this.hasVrack = function () {\n    return this.infra.vlan.hasVrack();\n  };\n  /*= =========================\n  =            IP            =\n  ========================== */\n\n  /**\n   * Attach an IP to a VM\n   */\n\n\n  this.attachIptoVm = function (ip, vm) {\n    if (ip.status === 'DRAFT') {\n      // @todo\n      return $q.when('TODO').then(function () {\n        self.saveToUserPref();\n      });\n    }\n\n    return ip.attach(vm.id).then(function () {\n      switch (ip.type) {\n        case 'failover':\n          // WARNING: Never return promise because pulling had to live on her side\n          self.pollIps(ip.type);\n          break;\n\n        default:\n          break;\n      } // @todo: other types\n\n    });\n  };\n\n  function rearrangeIpv6(instance) {\n    var publicIpV4Index = _.findIndex(instance.ipAddresses, {\n      version: 4,\n      type: 'public'\n    });\n\n    var publicIpV6Index = _.findIndex(instance.ipAddresses, {\n      version: 6,\n      type: 'public'\n    });\n\n    if (publicIpV4Index !== -1 && publicIpV6Index !== -1) {\n      instance.ipAddresses[publicIpV4Index].ipV6 = {\n        ip: instance.ipAddresses[publicIpV6Index].ip,\n        gateway: instance.ipAddresses[publicIpV6Index].gatewayIp\n      }; // eslint-disable-line\n\n      instance.ipAddresses.splice(publicIpV6Index, 1);\n    }\n  }\n  /**\n   *  Get list of IPs Public (from the list of VMs)\n   */\n\n\n  function getPublicIpAddressesFromInstances(vms) {\n    var publicIpAddresses = [];\n    angular.forEach(vms, function (vm) {\n      rearrangeIpv6(vm);\n      angular.forEach(_.filter(vm.ipAddresses, {\n        type: 'public'\n      }), function (publicIpAddress) {\n        _.set(publicIpAddress, 'id', publicIpAddress.ip);\n\n        _.set(publicIpAddress, 'routedTo', vm.id);\n\n        publicIpAddresses.push(publicIpAddress);\n      });\n    });\n    return publicIpAddresses;\n  }\n  /**\n   *  Make the links between VMs and IPs\n   */\n\n\n  this.refreshLinks = function () {\n    angular.forEach(self.infra.internet.ipList.items, function (ip) {\n      self.infra.refreshVmsRoutedToFromIp(ip);\n    });\n    $rootScope.$broadcast('infra.refresh.links');\n  };\n  /* -----  End of IPs  ------*/\n\n  /*= ==============================\n  =            POLLING            =\n  =============================== */\n\n  /**\n   *  --- [IPs] --- [update] ---\n   *\n   * Updates instances from API with instances from this factory\n   *  /!\\ This don't add or remove instances!\n   */\n\n\n  function updateIpsWithIpsFromApi(ipsFromApi) {\n    angular.forEach(ipsFromApi, function (ipFromApi) {\n      var ipFromFactory = self.infra.internet.getIpById(ipFromApi.id);\n\n      if (!ipFromFactory) {\n        return;\n      }\n\n      ipFromFactory.setInfos(ipFromApi);\n    });\n  }\n  /**\n   *  --- [IPs] --- [addOrDelete] ---\n   *\n   *  Add or remove IPs from API with IPs from this factory\n   *  /!\\ This can't update existing datas!!!\n   */\n\n\n  function addOrDeleteIpsWithIpsFromApi(ipsFromApi, type, forceRemoveDrafts) {\n    /*= =========  Remove deleted IPs  ========== */\n    var deletedIps = _.filter(self.infra.internet.ipList.items, function (ip) {\n      // don't remove drafts!\n      if (ip.type !== type || !forceRemoveDrafts && ip.status === 'DRAFT') {\n        return false;\n      }\n\n      return !_.find(ipsFromApi, {\n        id: ip.id\n      });\n    });\n\n    angular.forEach(deletedIps, function (ip) {\n      self.infra.internet.removeIpFromList(ip);\n    });\n    /*= =========  Add new IPs  ========== */\n\n    var addedIps = _.filter(ipsFromApi, function (ip) {\n      return !self.infra.internet.getIpById(ip.id);\n    });\n\n    angular.forEach(addedIps, function (ip) {\n      _.set(ip, 'type', type);\n\n      ip = self.infra.internet.addIpToList(ip); // eslint-disable-line\n    }); // return true if updated\n\n    return !!(deletedIps.length || addedIps.length);\n  }\n  /**\n   *  Triggered by polling: Update IPs list\n   *\n   *  /!\\ take care to don't update all datas, user can be in edition for example.\n   */\n\n\n  function updateIpsFromPolling(ips, type) {\n    var haveChanges = false; // Update existing IPs\n\n    haveChanges = updateIpsWithIpsFromApi(ips, type) || haveChanges; // Add new IPs, and delete removed IPs\n\n    haveChanges = addOrDeleteIpsWithIpsFromApi(ips, type) || haveChanges;\n    self.refreshLinks();\n\n    if (haveChanges) {\n      self.saveToUserPref();\n    }\n\n    return $q.when(ips);\n  }\n  /**\n   *  --- [VMs] --- [update] ---\n   *\n   * Updates instances from API with instances from this factory\n   *  /!\\ This don't add or remove instances!\n   */\n\n\n  function updateInstancesWithInstancesFromApi(instancesFromApi, updateOnlySpecificDatas) {\n    var haveChanges = false;\n    angular.forEach(instancesFromApi, function (instanceFromApi) {\n      var instanceFromFactory = self.infra.vrack.getVmById(instanceFromApi.id);\n      var currentEditedVm = self.getEditedVm();\n\n      if (!instanceFromFactory) {\n        return;\n      }\n\n      if (updateOnlySpecificDatas) {\n        // Update status\n        if (instanceFromFactory.status !== instanceFromApi.status) {\n          var oldStatus = instanceFromFactory.status;\n          var hardRebootingSuspended = instanceFromFactory.status === 'HARD_REBOOT' && instanceFromApi.status === 'SUSPENDED'; // if hard rebooting a suspended project the API do not update the status correctly\n          // this bug is not easilly fixable for the API so we fix it on UX side\n\n          if (!hardRebootingSuspended) {\n            haveChanges = true;\n            instanceFromFactory.status = instanceFromApi.status;\n            $rootScope.$broadcast('compute.infrastructure.vm.status-update', instanceFromApi.status, oldStatus, instanceFromFactory);\n          }\n        } // Update this datas ONLY if vm is not in edition\n\n\n        if (!currentEditedVm || currentEditedVm && currentEditedVm.id && currentEditedVm.id !== instanceFromApi.id) {\n          // Update image reinstall\n          if (instanceFromApi.imageId && instanceFromFactory.image && instanceFromFactory.image.id && instanceFromApi.imageId !== instanceFromFactory.image.id) {\n            instanceFromFactory.imageId = instanceFromApi.imageId;\n            instanceFromFactory.getFullInformations();\n            haveChanges = true;\n          } // Update flavor upscaling\n\n\n          if (instanceFromApi.flavorId && instanceFromFactory.flavor && instanceFromFactory.flavor.id && instanceFromApi.flavorId !== instanceFromFactory.flavor.id) {\n            instanceFromFactory.flavorId = instanceFromApi.flavorId;\n            instanceFromFactory.getFullInformations();\n            haveChanges = true;\n          }\n        } // Update ipAddresses array\n\n\n        if (instanceFromApi.ipAddresses && instanceFromApi.ipAddresses.length && (!instanceFromFactory.ipAddresses || instanceFromFactory.ipAddresses.length !== instanceFromApi.ipAddresses.length)) {\n          instanceFromFactory.ipAddresses = instanceFromApi.ipAddresses;\n          haveChanges = true;\n        } // Update monthlyBilling\n\n\n        if (!instanceFromFactory.monthlyBilling && instanceFromApi.monthlyBilling) {\n          haveChanges = true;\n          instanceFromFactory.monthlyBilling = angular.copy(instanceFromApi.monthlyBilling);\n        } // Update monthlyBilling status\n\n\n        if (instanceFromFactory.monthlyBilling && instanceFromApi.monthlyBilling && instanceFromFactory.monthlyBilling.status !== instanceFromApi.monthlyBilling.status) {\n          haveChanges = true;\n          var _oldStatus = instanceFromFactory.monthlyBilling.status;\n          instanceFromFactory.monthlyBilling.status = instanceFromApi.monthlyBilling.status;\n          $rootScope.$broadcast('compute.infrastructure.vm.monthlyBilling.status-update', instanceFromApi.status, _oldStatus, instanceFromFactory);\n        }\n      } else {\n        // Updates all infos\n        instanceFromFactory.setInfos(instanceFromApi);\n        haveChanges = true;\n      }\n    });\n    return haveChanges;\n  }\n  /*= ===================================================\n    =            LOCAL DATAS UPGRADE (by API)            =\n    ======================================================\n    * =README=\n    * Add, upgrade, and delete VMs or IPs lists with datas from APIs.\n    * Used at initialization, and with polling.\n    **************************************************** */\n\n  /**\n   *  --- [VMs] --- [addOrDelete] ---\n   *\n   *  Add or remove instances from API with instances from this factory\n   *  /!\\ This can't update existing datas!!!\n   */\n\n\n  function addOrDeleteInstancesWithInstancesFromApi(instancesFromApi, forceRemoveDrafts) {\n    /*= =========  Remove deleted instances  ========== */\n    var deletedInstances = _.filter(self.infra.vrack.publicCloud.items, function (vm) {\n      // don't remove drafts!\n      if (!forceRemoveDrafts && vm.status === 'DRAFT') {\n        return false;\n      }\n\n      var instance = _.find(instancesFromApi, {\n        id: vm.id\n      });\n\n      return !instance || instance.status === 'DELETED';\n    });\n\n    angular.forEach(deletedInstances, function (vm) {\n      self.infra.vrack.removeVmFromPublicCloudList(vm);\n    });\n    /*= =========  Add new instances  ========== */\n\n    var addedInstances = _.filter(instancesFromApi, function (vm) {\n      return vm.status !== 'DELETED' && !self.infra.vrack.getVmById(vm.id);\n    });\n\n    angular.forEach(addedInstances, function (vm) {\n      self.infra.vrack.addVmToPublicCloudList(vm);\n    }); // return true if updated\n\n    return !!(deletedInstances.length || addedInstances.length);\n  }\n  /* -----  End of LOCAL DATAS UPGRADE  ------*/\n\n  /**\n   *  Triggered by polling: Update instances list\n   *\n   *  /!\\ take care to don't update all datas, user can be in edition for example.\n   */\n\n\n  function updateInstancesFromPolling(instances) {\n    var haveChanges = false; // Update existing VMs\n\n    haveChanges = updateInstancesWithInstancesFromApi(instances, true) || haveChanges; // Add new VMs, and delete removed VMs\n\n    haveChanges = addOrDeleteInstancesWithInstancesFromApi(instances) || haveChanges; // Public IPs are into the instance infos, so we need to took them\n\n    var publicIpAddresses = getPublicIpAddressesFromInstances(instances);\n    updateIpsWithIpsFromApi(publicIpAddresses, 'public');\n    addOrDeleteIpsWithIpsFromApi(publicIpAddresses, 'public');\n    self.refreshLinks();\n\n    if (haveChanges) {\n      self.saveToUserPref();\n      CloudProjectComputeVolumesOrchestrator.pollVolumes(); // [async]\n    }\n\n    return $q.when(instances);\n  }\n  /**\n   *  --- [VMs] --- POLLING ---\n   *\n   *  Poll VM query\n   */\n\n\n  this.pollVms = function () {\n    var continueStatus = ['DELETING', 'BUILDING', 'HARD_REBOOT', 'REBOOT', 'REBUILD', 'REVERT_RESIZE', 'VERIFY_RESIZE', 'MIGRATING', 'RESIZE', 'BUILD', 'RESCUING', 'UNRESCUING', 'RESCUE', 'SNAPSHOTTING', 'RESUMING'];\n    Poller.poll(\"/cloud/project/\".concat(self.infra.serviceName, \"/instance\"), null, {\n      successRule: function successRule(vm) {\n        return (!vm.monthlyBilling || vm.monthlyBilling && vm.monthlyBilling.status !== 'activationPending') && _.every(continueStatus, function (continueState) {\n          return vm.status !== continueState;\n        });\n      },\n      namespace: 'cloud.infra.vms',\n      notifyOnError: false\n    }).then(function (vms) {\n      updateInstancesFromPolling(vms);\n    }, function (err) {\n      if (err && err.status) {\n        console.warn('pollVms', err); // @todo add bugkiller here\n      }\n    }, function (vms) {\n      updateInstancesFromPolling(vms);\n    });\n  };\n  /**\n   *  --- [VMs] --- POLLING KILL ---\n   *\n   *  Kill the Poll VM query\n   */\n\n\n  this.killPollVms = function () {\n    Poller.kill({\n      namespace: 'cloud.infra.vms'\n    });\n  }; // ---\n\n  /**\n   *  --- [IPs] --- POLLING ---\n   *\n   *  Poll IPs list\n   *  [ip] : the type of the IPs\n   */\n\n\n  this.pollIps = function (type) {\n    return Poller.poll(\"/cloud/project/\".concat(self.infra.serviceName, \"/ip/\").concat(type), null, {\n      successRule: function successRule(ip) {\n        return ip.status === 'ok';\n      },\n      namespace: 'cloud.infra.ips'\n    }).then(function (ips) {\n      updateIpsFromPolling(ips, type);\n    }, function (err) {\n      if (err && err.status) {\n        console.warn('pollIps', err); // @todo add bugkiller here\n      }\n    }, function (ips) {\n      updateIpsFromPolling(ips, type);\n    });\n  };\n  /**\n   *  --- [IPs] --- POLLING KILL ---\n   *\n   *  Kill the Poll IPs query\n   */\n\n\n  this.killPollIps = function () {\n    Poller.kill({\n      namespace: 'cloud.infra.ips'\n    });\n  };\n  /* -----  End of Polling  ------*/\n\n  /*= ===================================\n  =            UserPref            =\n  ==================================== */\n\n\n  this.saveToUserPref = function () {\n    return CloudUserPref.set(\"cloud_project_\".concat(self.infra.serviceName, \"_infra\"), self.infra.prepareToJson());\n  };\n\n  this.createFromUserPref = function (serviceName) {\n    var key = \"cloud_project_\".concat(serviceName, \"_infra\");\n    return CloudUserPref.get(key).then(function (infra) {\n      _.set(infra, 'serviceName', serviceName);\n\n      return new CloudProjectComputeInfrastructureFactory(infra);\n    }, function () {\n      return new CloudProjectComputeInfrastructureFactory({\n        serviceName: serviceName\n      });\n    });\n  };\n  /**\n   * Initialize an infrastructure\n   */\n\n\n  function initExistingProject(opts) {\n    return self.createFromUserPref(opts.serviceName).then(function (infraFromUserPref) {\n      var initQueue = [];\n      self.infra = infraFromUserPref;\n      /*= =========  VMs  ========== */\n\n      initQueue.push(OvhApiCloudProjectInstance.v6().query({\n        serviceName: self.infra.serviceName\n      }).$promise.then(function (instances) {\n        _.forEach(instances, function (instance) {\n          rearrangeIpv6(instance);\n        }); // Merge with local datas\n\n\n        updateInstancesWithInstancesFromApi(instances);\n        addOrDeleteInstancesWithInstancesFromApi(instances, true); // Public IPs are into the instance infos, so we need to took them\n\n        var publicIpAddresses = getPublicIpAddressesFromInstances(instances);\n        updateIpsWithIpsFromApi(publicIpAddresses, 'public');\n        addOrDeleteIpsWithIpsFromApi(publicIpAddresses, 'public', true);\n      }));\n      /*= =========  IPs  ========== */\n\n      var ipTypes = ['failover'];\n      angular.forEach(ipTypes, function (ipType) {\n        initQueue.push(OvhApiCloudProjectIp[ipType].v6().query({\n          serviceName: self.infra.serviceName\n        }).$promise.then(function (ips) {\n          angular.forEach(ips, function (ip) {\n            _.set(ip, 'type', ipType);\n          });\n          return ips;\n        }).then(function (ips) {\n          // Merge with local datas\n          updateIpsWithIpsFromApi(ips, ipType);\n          addOrDeleteIpsWithIpsFromApi(ips, ipType, true);\n        }));\n      });\n      return $q.all(initQueue).then(function () {\n        self.refreshLinks();\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n\n        self.pollIps('failover'); // WARNING: Never return promise because pulling had to live on her side\n\n        return self.infra;\n      });\n    });\n  }\n  /**\n   *  Initialize a new Infrastructure\n   */\n\n\n  this.init = function (opts) {\n    resetDatas();\n    return initExistingProject(opts);\n  };\n}]);",null]}