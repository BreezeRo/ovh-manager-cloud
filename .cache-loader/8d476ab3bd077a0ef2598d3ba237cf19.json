{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/storage/services/container-tasks-runner.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/storage/services/container-tasks-runner.service.js","mtime":1539717142051},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["/* eslint-disable no-param-reassign, prefer-destructuring, consistent-return */\nangular.module('managerApp').service('CloudStorageContainerTasksRunner', [\n  '$q',\n  '$rootScope',\n  function CloudStorageContainerTasksRunner($q, $rootScope) {\n    const defaultQueueName = 'main';\n    let taskQueues = {};\n\n    const self = this;\n\n    self.limit = 4;\n\n    /**\n     * Flush tasks.\n     */\n    self.flush = function () {\n      taskQueues = {};\n    };\n\n    /**\n     * Get queue list.\n     * @return {Array} queue list\n     */\n    self.getQueues = function () {\n      return taskQueues;\n    };\n\n    /**\n     * Count number of running tasks.\n     * @return {number} number of running tasks\n     */\n    self.countRunningTasks = function () {\n      return self.countTasks('running');\n    };\n\n    /**\n     * Count total number of tasks.\n     * @return {number} total number of tasks\n     */\n    self.countTotalTasks = function () {\n      return self.countTasks('total');\n    };\n\n    /**\n     * Count number of pending tasks.\n     * @return {number} number of pending tasks\n     */\n    self.countPendingTasks = function () {\n      return self.countTotalTasks() - self.countDoneTasks() - self.countErrorTasks();\n    };\n\n    /**\n     * Count number of done tasks.\n     * @return {number} number of done tasks\n     */\n    self.countDoneTasks = function () {\n      return self.countTasks('success');\n    };\n\n    /**\n     * Count tasks in error.\n     * @return {number} number of tasks in error\n     */\n    self.countErrorTasks = function () {\n      return self.countTasks('error');\n    };\n\n    /**\n     * Count number of tasks in a specific state.\n     * @params {...string} states to count\n     * @return {number} number of tasks in theses states\n     */\n    self.countTasks = function () {\n      const states = arguments; // eslint-disable-line\n      return _.chain(_.values(taskQueues))\n        .reduce((result, queue) => {\n          const currentSum = _.chain(queue).pick(states).sum().value();\n          return result + currentSum;\n        }, 0)\n        .value();\n    };\n\n    /**\n     * Add task to a queue.\n     * @param  {string}    queueName  Queue name (optional, default: \"main\")\n     * @param  {Function}  task       List of functions returning promises\n     * @return {Promise} the promise for all this task queue\n     */\n    self.addTask = function (queueName, task) {\n      if (!task) {\n        task = queueName;\n        queueName = defaultQueueName;\n      }\n\n      this.enqueue(queueName, [task]);\n\n      const queue = taskQueues[queueName];\n\n      return queue.defer.promise;\n    };\n\n    function decorateTask(task) {\n      return $q.when()\n        .then(() => {\n          $rootScope.$broadcast('cloudStorageContainerTasksRunner:start_task');\n          return task();\n        })\n        .then((result) => {\n          $rootScope.$broadcast('cloudStorageContainerTasksRunner:finish_task', {\n            status: 'success',\n            payload: result,\n          });\n          return result;\n        })\n        .catch((error) => {\n          $rootScope.$broadcast('cloudStorageContainerTasksRunner:finish_task', {\n            status: 'error',\n            payload: error,\n          });\n          return $q.reject(error);\n        });\n    }\n\n    /**\n     * Create controlled tasks queue.\n     * @param  {string}           queueName   Queue name (optional, default: \"main\")\n     * @param  {Array<Function>}  tasks       List of functions returning promises\n     * @param  {number}           limit       Concurrency limit (default: 3)\n     * @return {Promise} the promise for all this task queue\n     */\n    self.enqueue = function (queueName, tasks, limit) {\n      if (_.isArray(queueName)) {\n        tasks = queueName;\n        limit = tasks;\n        queueName = defaultQueueName;\n        if (!_.isNumber(limit)) {\n          limit = self.limit;\n        }\n      }\n\n      const defer = $q.defer();\n\n      function next(queue) {\n        if (!queue.remainingTasks.length && queue.running === 0) {\n          return queue.defer.resolve({\n            success: queue.successOutput,\n            error: queue.errorOutput,\n          });\n        }\n\n        while (queue.remainingTasks.length > 0 && queue.running < queue.limit) {\n          const task = queue.remainingTasks.shift();\n          queue.running += 1;\n          decorateTask(task)\n            .then((data) => {\n              queue.successOutput.push(data);\n              queue.success += 1;\n            })\n            .catch((err) => {\n              queue.errorOutput.push(err);\n              queue.error += 1;\n            })\n            .finally(() => {\n              queue.running -= 1;\n              queue.defer.notify(queue);\n              next(queue);\n            }); // jshint ignore:line\n        }\n      }\n\n      let queue = taskQueues[queueName];\n\n      if (queue && !queue.remainingTasks.length && queue.running === 0) {\n        self.flush();\n        queue = null;\n      }\n\n      if (!queue) {\n        queue = {\n          name: queueName,\n          limit: limit || self.limit,\n          running: 0,\n          success: 0,\n          error: 0,\n          defer,\n          remainingTasks: tasks,\n          total: tasks.length,\n          successOutput: [],\n          errorOutput: [],\n        };\n        taskQueues[queueName] = queue;\n        next(queue);\n      } else {\n        queue.remainingTasks = queue.remainingTasks.concat(tasks);\n        queue.total += tasks.length;\n      }\n\n      return defer.promise;\n    };\n  }]);\n/* eslint-enable no-param-reassign, prefer-destructuring, consistent-return */\n"]}