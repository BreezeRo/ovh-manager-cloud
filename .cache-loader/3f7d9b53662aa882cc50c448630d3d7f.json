{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/iplb/frontends/iplb-frontends-edit.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/iplb/frontends/iplb-frontends-edit.controller.js","mtime":1539717142196},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["class IpLoadBalancerFrontendsEditCtrl {\n  constructor($q, $state, $stateParams, $translate, CloudMessage, ControllerHelper,\n    IpLoadBalancerConstant, IpLoadBalancerFailoverIpService,\n    IpLoadBalancerFrontendsService, IpLoadBalancerZoneService) {\n    this.$q = $q;\n    this.$state = $state;\n    this.$stateParams = $stateParams;\n    this.$translate = $translate;\n    this.CloudMessage = CloudMessage;\n    this.ControllerHelper = ControllerHelper;\n    this.IpLoadBalancerConstant = IpLoadBalancerConstant;\n    this.IpLoadBalancerFailoverIpService = IpLoadBalancerFailoverIpService;\n    this.IpLoadBalancerFrontendsService = IpLoadBalancerFrontendsService;\n    this.IpLoadBalancerZoneService = IpLoadBalancerZoneService;\n\n    this.initLoaders();\n  }\n\n  initLoaders() {\n    this.zones = this.ControllerHelper.request.getArrayLoader({\n      loaderFunction: () => this.IpLoadBalancerZoneService.getZonesSelectData(\n        this.$stateParams.serviceName,\n      ),\n    });\n    this.farms = this.ControllerHelper.request.getArrayLoader({\n      loaderFunction: () => this.IpLoadBalancerFrontendsService.getFarmsChoices(\n        this.getFarmType(),\n        this.$stateParams.serviceName,\n        this.frontend.zone,\n      ),\n    });\n    this.certificates = this.ControllerHelper.request.getArrayLoader({\n      loaderFunction: () => this.IpLoadBalancerFrontendsService.getCertificatesChoices(\n        this.$stateParams.serviceName,\n      ),\n    });\n    this.failoverIps = this.ControllerHelper.request.getHashLoader({\n      loaderFunction: () => this.IpLoadBalancerFailoverIpService.getFailoverIpsSelectData(\n        this.$stateParams.serviceName,\n      ),\n    });\n    this.apiFrontend = this.ControllerHelper.request.getHashLoader({\n      loaderFunction: () => this.IpLoadBalancerFrontendsService.getAllFrontendsTypes(\n        this.$stateParams.serviceName,\n      )\n        .then((frontends) => {\n          const frontend = _.find(frontends, {\n            id: parseInt(this.$stateParams.frontendId, 10),\n          });\n          return this.IpLoadBalancerFrontendsService.getFrontend(\n            frontend.type,\n            this.$stateParams.serviceName,\n            this.$stateParams.frontendId,\n          );\n        }).then(frontend => this.parseFrontend(frontend)),\n    });\n  }\n\n  getFarmType() {\n    switch (this.protocol) {\n      case 'http':\n      case 'https':\n        return 'http';\n      case 'tcp':\n      case 'tls':\n        return 'tcp';\n      default:\n        return this.protocol;\n    }\n  }\n\n  getFarmName(farm) {\n    const farmName = farm.displayName || farm.farmId;\n    if (farm.farmId > 0) {\n      const farmType = this.$translate.instant(`iplb_frontend_add_protocol_${farm.type}`);\n      return `${farmName} (${farmType})`;\n    }\n    return farmName;\n  }\n\n  static getCertificateName(certificate) {\n    if (certificate.id <= 0) {\n      return certificate.displayName;\n    }\n    return certificate.displayName ? `${certificate.displayName} (${certificate.id})` : certificate.id;\n  }\n\n  onProtocolChange() {\n    this.farmType = this.getFarmType();\n    switch (this.protocol) {\n      case 'http':\n        this.type = 'http';\n        this.frontend.port = 80;\n        this.frontend.ssl = false;\n        break;\n      case 'https':\n        this.type = 'http';\n        this.frontend.port = 443;\n        this.frontend.ssl = true;\n        this.frontend.hsts = false;\n        break;\n      case 'tcp':\n        this.type = 'tcp';\n        delete this.frontend.port;\n        this.frontend.ssl = false;\n        break;\n      case 'udp':\n        this.type = 'udp';\n        delete this.frontend.port;\n        this.frontend.ssl = false;\n        break;\n      case 'tls':\n        this.type = 'tcp';\n        delete this.frontend.port;\n        this.frontend.ssl = true;\n        break;\n      default: break;\n    }\n\n    if (this.frontend.ssl) {\n      this.certificates.load();\n    }\n\n    this.farms.load();\n  }\n\n  onZoneChange() {\n    this.frontend.defaultFarmId = null;\n    this.farms.load();\n  }\n\n  $onInit() {\n    this.frontend = {\n      dedicatedIpfo: [],\n      defaultSslId: 0,\n      defaultFarmId: 0,\n      port: 80,\n      ssl: false,\n      hsts: false,\n    };\n    this.type = 'http';\n    this.protocol = 'http';\n    this.saving = false;\n    this.protocols = this.IpLoadBalancerConstant.protocols;\n    this.portLimit = this.IpLoadBalancerConstant.portLimit;\n\n    this.zones.load();\n    this.failoverIps.load();\n\n    if (this.$stateParams.frontendId) {\n      this.edition = true;\n      this.apiFrontend.load()\n        .then(() => {\n          this.farms.load();\n        });\n    } else {\n      this.farms.load();\n    }\n  }\n\n  static validateSelection(value) {\n    return value && value !== '0';\n  }\n\n  isProtocolDisabled(protocol) {\n    if (!this.edition) {\n      return false;\n    }\n\n    if (this.type === 'http' && /http/.test(protocol)) {\n      return false;\n    } if (this.protocol === protocol) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Parse frontend object from API and send it to form.\n   * @return parsed frontend object\n   */\n  parseFrontend(frontend) {\n    this.type = frontend.protocol;\n    switch (frontend.protocol) {\n      case 'http':\n        this.protocol = frontend.ssl ? 'https' : 'http';\n        break;\n      case 'tcp':\n        this.protocol = frontend.ssl ? 'tls' : 'tcp';\n        break;\n      case 'udp':\n        this.protocol = 'udp';\n        break;\n      default: break;\n    }\n\n    if (_.has(frontend, 'allowedSource.length')) {\n      _.set(frontend, 'allowedSource', frontend.allowedSource.join(', '));\n    }\n\n    this.frontend = angular.copy(frontend);\n    return frontend;\n  }\n\n  /**\n   * Clean frontend from form and send it to API.\n   * @return clean frontend object\n   */\n  getCleanFrontend() {\n    const request = angular.copy(this.frontend);\n    if (this.type === 'udp') {\n      delete request.ssl;\n    }\n\n    if (_.includes(['udp', 'tcp'], this.type)) {\n      delete request.hsts;\n    }\n\n    if (!request.ssl || !request.defaultSslId) {\n      delete request.defaultSslId;\n    }\n    if (!request.defaultFarmId && request.defaultFarmId === 0) {\n      delete request.defaultFarmId;\n    } else if (request.defaultFarmId === 0) {\n      request.defaultFarmId = null;\n    }\n    if (this.frontend.allowedSource) {\n      request.allowedSource = _.map(this.frontend.allowedSource.split(','), source => _.trim(source));\n    }\n    delete request.protocol;\n    return request;\n  }\n\n  sendForm() {\n    if (this.$stateParams.frontendId) {\n      this.updateFrontend();\n    } else {\n      this.addFrontend();\n    }\n  }\n\n  createFrontend() {\n    if (this.form.$invalid) {\n      return this.$q.reject();\n    }\n    this.saving = true;\n    this.CloudMessage.flushChildMessage();\n    return this.IpLoadBalancerFrontendsService\n      .createFrontend(this.type, this.$stateParams.serviceName, this.getCleanFrontend())\n      .then(() => this.$state.go('network.iplb.detail.frontends'))\n      .finally(() => {\n        this.saving = false;\n      });\n  }\n\n  updateFrontend() {\n    if (this.form.$invalid) {\n      return this.$q.reject();\n    }\n    this.saving = true;\n    this.CloudMessage.flushChildMessage();\n    return this.IpLoadBalancerFrontendsService\n      .updateFrontend(\n        this.type,\n        this.$stateParams.serviceName,\n        this.frontend.frontendId,\n        this.getCleanFrontend(),\n      )\n      .then(() => this.$state.go('network.iplb.detail.frontends'))\n      .finally(() => {\n        this.saving = false;\n      });\n  }\n}\n\nangular.module('managerApp').controller('IpLoadBalancerFrontendsEditCtrl', IpLoadBalancerFrontendsEditCtrl);\n"]}