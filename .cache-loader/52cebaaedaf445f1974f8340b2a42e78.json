{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/dbaas/logs/detail/streams/archives/streams-archives.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/dbaas/logs/detail/streams/archives/streams-archives.controller.js","mtime":1539717142148},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["class LogsStreamsArchivesCtrl {\n  constructor($interval, $state, $stateParams, $translate, CloudMessage, ControllerHelper,\n    LogsStreamsService, LogsConstants, LogsStreamsArchivesService) {\n    this.$interval = $interval;\n    this.$state = $state;\n    this.$stateParams = $stateParams;\n    this.$translate = $translate;\n    this.CloudMessage = CloudMessage;\n    this.ControllerHelper = ControllerHelper;\n    this.LogsStreamsService = LogsStreamsService;\n    this.LogsConstants = LogsConstants;\n    this.LogsStreamsArchivesService = LogsStreamsArchivesService;\n\n    this.serviceName = this.$stateParams.serviceName;\n    this.streamId = this.$stateParams.streamId;\n    this.initLoaders();\n  }\n\n  $onInit() {\n    this.archiveIds.load();\n    this.stream.load();\n    this.notifications = [];\n  }\n\n  $destroy() {\n    this.stopRetrievalDelayUpdate();\n  }\n\n  /**\n   * Gets the notificaiton index for an archive if available\n   *\n   * @param {any} archive\n   * @returns the notification index. Returns -1 if not found\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  getNotificationIndex(archive) {\n    return this.notifications\n      .reduce(\n        (matchedIndex, currentNotification, currentIndex) => (currentNotification.archive\n          .archiveId === archive.archiveId ? currentIndex : matchedIndex), -1,\n      );\n  }\n\n  /**\n   * initializes the archivesIDs and current stream\n   *\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  initLoaders() {\n    this.archiveIds = this.ControllerHelper.request.getArrayLoader({\n      loaderFunction: () => this.LogsStreamsArchivesService\n        .getArchiveIds(this.serviceName, this.streamId),\n    });\n    this.stream = this.ControllerHelper.request.getHashLoader({\n      loaderFunction: () => this.LogsStreamsService.getStream(this.serviceName, this.streamId),\n    });\n  }\n\n  /**\n   * Updates the list of archive with the latest information of the archive\n   *\n   * @param {any} archiveId\n   * @returns promise which will be resolve with the reloaded archive\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  reloadArchiveDetail(archiveId) {\n    this.archiveReload = this.ControllerHelper.request.getArrayLoader({\n      loaderFunction: () => this.LogsStreamsArchivesService.getArchives(\n        this.serviceName,\n        this.streamId,\n        [archiveId],\n      ),\n    });\n\n    return this.archiveReload.load()\n      .then((archives) => {\n        const archive = archives[0];\n        this.archives.data.forEach((archiveItem, archiveIndex) => {\n          if (archiveItem.archiveId === archive.archiveId) {\n            this.archives.data[archiveIndex] = archive;\n          }\n        });\n        return archive;\n      });\n  }\n\n  /**\n   * Removes the notification for an archive if available\n   *\n   * @param {any} archive\n   * @returns Returns the removed notification\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  removeNotification(archive) {\n    const notificationIndex = this.getNotificationIndex(archive);\n    return this.notifications.splice(notificationIndex, notificationIndex >= 0 ? 1 : 0);\n  }\n\n  /**\n   * Starts an interval that runs every second, that updates\n   * the remaining unsealing time for all archives being unsealed\n   *\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  startRetrievalDelayUpdate() {\n    this.retrievalDelayUpdater = this.$interval(() => this.updateRetrievalDelay(), 1000);\n  }\n\n  /**\n   * Stops the interval that updates the remaining unsealing\n   * time for all archives being unsealed\n   *\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  stopRetrievalDelayUpdate() {\n    this.$interval.cancel(this.retrievalDelayUpdater);\n  }\n\n  /**\n   * Updates the notification for an archive if available. Else adds the notification\n   *\n   * @param {any} archive\n   * @param {any} notification\n   * @returns Returns the updated/inserted notification\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  updateNotification(notification) {\n    const notificationIndex = this.getNotificationIndex(notification.archive);\n    if (notificationIndex >= 0) {\n      this.notifications[notificationIndex] = notification;\n    } else {\n      this.notifications.push(notification);\n    }\n    return this.notifications;\n  }\n\n  /**\n   * Loops through all archives and reduces the remaining unsealing\n   * time for archives being unsealed. Also sets an archive to available\n   * when the unsealing is complete and issues a notification\n   *\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  updateRetrievalDelay() {\n    _.clone(this.notifications).forEach((notification) => {\n      const { archive } = notification;\n      archive.retrievalDelay = archive.retrievalDelay > 0\n        ? archive.retrievalDelay -= 1\n        : archive.retrievalDelay;\n      if (archive.retrievalState === this.LogsConstants.state.UNSEALING) {\n        if (archive.retrievalDelay === 0) {\n          archive.retrievalState = this.LogsConstants.state.UNSEALED;\n          this.LogsStreamsArchivesService.transformArchive(archive);\n        }\n        this.updateUnfreezingNotification(archive);\n      }\n    });\n  }\n\n  /**\n   * Updates the notification for an archive that is being unsealed.\n   * If the archive is not being unsealed, the notification is removed\n   *\n   * @param {any} archive\n   * @returns Returns the updated/removed notification\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  updateUnfreezingNotification(archive) {\n    return archive.retrievalState === this.LogsConstants.state.UNSEALING\n      ? [this.updateNotification({\n        text: this.$translate.instant('streams_archives_unfreezing', {\n          name: archive.filename,\n          time: moment.utc(archive.retrievalDelay * 1000).format('HH:mm:ss'),\n        }),\n        type: 'info',\n        archive,\n      })]\n      : this.removeNotification(archive);\n  }\n\n  /**\n   * Gets the URL for an archive and downloads it\n   *\n   * @param {any} archive\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  download(archive) {\n    this.updateNotification({\n      text: this.$translate.instant('streams_archives_preparing_download', {\n        filename: archive.filename,\n      }),\n      type: 'info',\n      archive,\n    });\n    this.ControllerHelper.scrollPageToTop();\n    this.archiveDownload = this.ControllerHelper.request.getHashLoader({\n      loaderFunction: () => this.LogsStreamsArchivesService\n        .getDownloadUrl(this.serviceName, this.streamId, archive.archiveId),\n    });\n\n    this.archiveDownload.load()\n      .then((urlInfo) => {\n        this.removeNotification(archive);\n        this.ControllerHelper.constructor.downloadUrl(urlInfo.url);\n      });\n  }\n\n  /**\n   * Loads a number of archives specified by the pageSize, starting from the specified offset\n   * Also issues a notification for archives being unsealed\n   *\n   * @param {any} offset\n   * @param {any} pageSize\n   * @returns promise which will be resolve to the loaded archives data\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  loadArchives({ offset, pageSize }) {\n    this.stopRetrievalDelayUpdate();\n    this.archives = this.ControllerHelper.request.getArrayLoader({\n      loaderFunction: () => this.LogsStreamsArchivesService.getArchives(\n        this.serviceName,\n        this.streamId,\n        this.archiveIds.data.slice(offset - 1, offset + pageSize - 1),\n      ),\n    });\n    return this.archives.load()\n      .then(archives => ({\n        data: archives,\n        meta: {\n          totalCount: this.archiveIds.data.length,\n        },\n      }))\n      .then(this.startRetrievalDelayUpdate())\n      .then((archivesData) => {\n        archivesData.data.forEach(archive => this.updateUnfreezingNotification(archive));\n        return archivesData;\n      });\n  }\n\n  /**\n   * Starts the unsealing process for an archive and issues a notification\n   * with the remaining time after which the archive would be available for download\n   *\n   * @param {any} archive\n   * @memberof LogsStreamsArchivesHomeCtrl\n   */\n  unfreeze(archive) {\n    this.updateNotification({\n      text: this.$translate.instant('streams_archives_unfreeze_start', {\n        filename: archive.filename,\n      }),\n      type: 'info',\n      archive,\n    });\n    this.ControllerHelper.scrollPageToTop();\n    this.LogsStreamsArchivesService.getDownloadUrl(\n      this.serviceName,\n      this.streamId,\n      archive.archiveId,\n    )\n      .then(() => this.reloadArchiveDetail(archive.archiveId))\n      .then(updatedArchive => this.updateUnfreezingNotification(updatedArchive))\n      .catch((err) => {\n        this.updateNotification({\n          text: this.$translate.instant('streams_archives_url_load_error', {\n            filename: archive.filename,\n            message: err,\n          }),\n          type: 'error',\n          archive,\n        });\n      });\n  }\n}\n\nangular.module('managerApp').controller('LogsStreamsArchivesCtrl', LogsStreamsArchivesCtrl);\n"]}