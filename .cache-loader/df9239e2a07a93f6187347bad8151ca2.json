{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/volumes/volumes-orchestrator.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/volumes/volumes-orchestrator.service.js","mtime":1539717142391},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["/**\n *  Cloud Volumes list Orchestrator. Heal the world we live in, save it for our children\n *  ====================================================================================\n *\n *  =README=\n *  This orchestrator is used to init and manage a Cloud Volumes list.\n */\nangular.module('managerApp').service('CloudProjectComputeVolumesOrchestrator',\n  function ($q, $translate, $rootScope, $timeout, CLOUD_INSTANCE_DEFAULTS, Poller, CloudUserPref,\n    OvhApiCloudProjectVolume, OvhApiCloudProjectVolumeSnapshot, CloudProjectComputeVolumesFactory,\n    OvhApiCloudProjectRegion, Toast) {\n    // Warning: all values must be reset at init (see resetDatas())\n    const self = this;\n    let editedVolume;\n    let paramEdition = null;\n    // enum NAME, SIZE\n    let currentVolumesMovePending;\n    const resetDatas = function () {\n      // The full volumes list to display\n      self.volumes = null;\n\n      // Project type (existing, template, template-new)\n      self.serviceType = null;\n\n      // Current edited volume\n      editedVolume = null;\n\n      // Current moving volumes IDs\n      // @todo: to reset when switching project\n      currentVolumesMovePending = [];\n\n      // Stop polling if launched\n      self.killPollVolumes();\n    };\n\n    /**\n     *  Get the default volume configuration options for a specified region\n     */\n    function getDefaultVolumeConfigurationForRegion(defaultRegion) {\n      const options = {\n        name: $translate.instant('cpci_volume_default_name'),\n        region: defaultRegion,\n        size: 100,\n        type: 'classic',\n        bootable: false,\n      }; const\n        optionsQueue = [];\n\n      // @todo: enums toussa\n\n      return $q.allSettled(optionsQueue).then(() => {\n        if (_.keys(self.volumes.volumes).length > 0) {\n          // use the most recent volume parameters\n          const mostRecentVolume = _.last(_.sortBy(_.flatten(_.values(self.volumes.volumes)), 'creationDate'));\n          if (mostRecentVolume) {\n            options.region = mostRecentVolume.region;\n            options.size = mostRecentVolume.size;\n            options.type = mostRecentVolume.type;\n          }\n        }\n        return options;\n      }, () => options);\n    }\n\n    /**\n     *  Get the default volume configuration options\n     */\n    const getDefaultVolumeConfiguration = function () {\n      return OvhApiCloudProjectRegion.v6().query({\n        serviceName: self.volumes.serviceName,\n      }).$promise.then((regionList) => {\n        // check if the default region exists\n        let { region } = CLOUD_INSTANCE_DEFAULTS;\n        if (_.indexOf(regionList, region) === -1) {\n          region = _.first(regionList);\n        }\n        return getDefaultVolumeConfigurationForRegion(region);\n      });\n    };\n\n    /**\n     *  Add a volume into project Volumes list\n     */\n    this.addNewVolumeToList = function (targetId) {\n      let volume;\n      return $q.when(true).then(() => getDefaultVolumeConfiguration()).then((options) => {\n        volume = self.volumes.addVolumeToList(options, targetId);\n        volume.status = 'DRAFT';\n        self.saveToUserPref();\n        return volume;\n      });\n    };\n\n    /**\n     * Add a volume from a given snapshot into project Volumes list\n     */\n    this.addNewVolumeFromSnapshotToList = function (targetId, snapshot) {\n      const getVolumeFromSnapshot = function (snapshot) { // eslint-disable-line\n        if (!snapshot || !snapshot.id) {\n          return $q.reject({ data: { message: 'Snapshot id cannot be found' } });\n        }\n        return OvhApiCloudProjectVolume.v6().get({\n          serviceName: self.volumes.serviceName,\n          volumeId: snapshot.volumeId,\n        }).$promise;\n      };\n\n      /**\n       * Since snapshot doesnt contains the volume type we need to fetch the volume.\n       * If the volume has been deleted the api still has a backup of it so it's not a problem.\n       */\n      return getVolumeFromSnapshot(snapshot).then((toRestore) => {\n        if (!toRestore || !toRestore.type) {\n          return $q.reject({ data: { message: 'Volume to restore cannot be found' } });\n        }\n        const options = {\n          name: snapshot.name || toRestore.name,\n          region: snapshot.region || toRestore.region,\n          size: snapshot.minDisk || toRestore.size,\n          type: toRestore.type,\n          bootable: toRestore.bootable,\n          snapshot,\n        };\n        const volume = self.volumes.addVolumeToList(options, targetId);\n        volume.status = 'DRAFT';\n        self.saveToUserPref();\n        return $q.when(volume);\n      });\n    };\n\n    /**\n     *  Launch the volume creation.\n     */\n    this.saveNewVolume = function (volume) {\n      return volume.create().then(() => {\n        self.saveToUserPref();\n        self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     *  Set the volume that is currently in edition\n     */\n    this.turnOnVolumeEdition = function (volume) {\n      editedVolume = volume;\n      editedVolume.startEdition();\n    };\n\n    /**\n     *  Close/Reset the volume that is currently in edition\n     */\n    this.turnOffVolumeEdition = function (reset) {\n      editedVolume.stopEdition(!!reset);\n      delete editedVolume.snapshot; // in case of snapshot restore, we delete snapshot reference\n      editedVolume = null;\n    };\n\n    /**\n     *  Get the volume that is currently in edition\n     */\n    this.getEditedVolume = function () {\n      return editedVolume;\n    };\n\n    /**\n     *  Get parameters for current edition\n     */\n    this.getEditVolumeParam = function () {\n      return paramEdition;\n    };\n\n    /**\n     *  Get parameters for current edition\n     */\n    this.setEditVolumeParam = function (param) {\n      paramEdition = param;\n    };\n\n    /**\n     *  Save the volume modifications\n     */\n    this.saveEditedVolume = function (volume) {\n      return volume.edit().then(() => {\n        self.saveToUserPref();\n        self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n         *  Delete volume\n         */\n    this.deleteVolume = function (volumeOrVolumeId) {\n      const volume = typeof volumeOrVolumeId === 'string' || typeof volumeOrVolumeId === 'number' ? self.volumes.getVolumeById(volumeOrVolumeId) : null;\n\n      if (!volume) {\n        return $q.reject({ data: { message: 'Volume id cannot be find' } });\n      }\n\n      if (volume.status === 'DRAFT') {\n        return $q.when(true).then(() => {\n          self.volumes.removeVolumeFromList(volume);\n          self.saveToUserPref();\n        });\n      }\n      return volume.remove().then(() => {\n        self.saveToUserPref();\n        self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n         *  Move a volume.\n         *  If targetId: move it to a vm, if not: move it to \"parking\"\n         */\n    this.moveVolume = function (volumeOrVolumeId, targetId) {\n      const volume = typeof volumeOrVolumeId === 'string' || typeof volumeOrVolumeId === 'number' ? self.volumes.getVolumeById(volumeOrVolumeId) : null;\n      targetId = targetId || 'unlinked'; // eslint-disable-line\n\n      if (!volume) {\n        return $q.reject({ data: { message: 'Volume id cannot be find' } });\n      }\n\n      const sourceId = volume.attachedTo && volume.attachedTo.length ? volume.attachedTo[0] : 'unlinked';\n      const action = (!targetId || targetId === 'unlinked') ? 'detach' : 'attach';\n\n      if (volume.status === 'DRAFT') {\n        // @todo\n        return $q.when('TODO').then(() => {\n          self.saveToUserPref();\n        });\n      }\n      // We need to hide it from previous location,\n      // and show it into its new location BEFORE the end of the task...\n      // To do that, we move it, and we put a special status.\n      self.volumes.removeVolumeFromList(volume, sourceId);\n      self.volumes.addVolumeToList(volume, targetId);\n      currentVolumesMovePending.push(volume.id);\n\n      volume.status = `${action}ing`;\n      return volume[action](action === 'detach' ? sourceId : targetId).then(() => {\n        self.pollVolumes(); // WARNING: Never return promise because pulling had to live on her side\n      }, (err) => {\n        // revert\n        self.volumes.addVolumeToList(volume, sourceId);\n        self.volumes.removeVolumeFromList(volume, targetId);\n        _.pull(currentVolumesMovePending, volume.id);\n        return $q.reject(err);\n      });\n    };\n\n    /**\n     * Create a snapshot of given volume.\n     */\n    this.snapshotVolume = function (volume, snapshotName) {\n      return OvhApiCloudProjectVolumeSnapshot.v6().create({\n        serviceName: self.volumes.serviceName,\n        volumeId: volume.id,\n      }, {\n        name: snapshotName,\n      }).$promise.then(() => {\n        _.set(volume, 'status', 'snapshotting');\n        self.pollVolumes();\n      }, err => $q.reject(err));\n    };\n\n    /* -----  End of VOLUMES  ------*/\n\n\n    /*= ==============================\n    =            POLLING            =\n    =============================== */\n\n    /**\n     *  --- [Volumes] --- [update] ---\n     *\n     * Updates volumes from API with volumes from this factory\n     *  /!\\ This don't add or remove volumes!\n     */\n    function updateVolumesWithVolumesFromApi(volumesFromApi, updateOnlySpecificDatas) {\n      let haveChanges = false;\n\n      angular.forEach(self.volumes.volumes, (volumesFromFactory, targetId) => {\n        if (!volumesFromApi[targetId] || !volumesFromFactory || !volumesFromFactory.length) {\n          return;\n        }\n\n        angular.forEach(volumesFromFactory, (volumeFromFactory) => {\n          const volumeFromApi = _.find(volumesFromApi[targetId], { id: volumeFromFactory.id });\n\n          if (!volumeFromApi) {\n            return;\n          }\n\n          // If the volume was in pending move, and now active, remove it from pendingArray.\n          if (~currentVolumesMovePending.indexOf(volumeFromFactory.id) && ~['available', 'in-use'].indexOf(volumeFromApi.status)) {\n            _.pull(currentVolumesMovePending, volumeFromFactory.id);\n          }\n\n          // If the volume was in snapshotting, and now active display success message\n          if (volumeFromFactory.status === 'snapshotting' && ~['available', 'in-use'].indexOf(volumeFromApi.status)) {\n            Toast.success($translate.instant('cpci_volume_snapshotting_end', { volume: volumeFromFactory.name }));\n          }\n\n          if (updateOnlySpecificDatas) {\n            // Update status\n            if (volumeFromFactory.status !== volumeFromApi.status) {\n              haveChanges = true;\n              _.set(volumeFromFactory, 'status', volumeFromApi.status);\n            }\n          } else {\n            // Updates all infos\n            volumeFromFactory.setInfos(volumeFromApi);\n            haveChanges = true;\n          }\n        });\n      });\n\n      return haveChanges;\n    }\n\n    /**\n     *  --- [Volumes] --- [addOrDelete] ---\n     *\n     *  Add or remove volumes from API with volumes from this factory\n     *  /!\\ This can't update existing datas!!!\n     */\n    function addOrDeleteVolumesWithVolumesFromApi(volumesFromApi, forceRemoveDrafts) {\n      let haveChanges = false;\n\n      /*= =========  Remove deleted volumes  ========== */\n\n      angular.forEach(self.volumes.volumes, (volumesFromFactory, targetId) => {\n        const deletedVolumes = _.filter(volumesFromFactory, (vol) => {\n          // don't remove drafts!\n          if (!forceRemoveDrafts && vol.status === 'DRAFT') {\n            return false;\n          }\n          return !volumesFromApi[targetId] || !_.find(volumesFromApi[targetId], { id: vol.id });\n        });\n\n        angular.forEach(deletedVolumes, (vol) => {\n          // Don't remove pending move\n          if (~currentVolumesMovePending.indexOf(vol.id)) {\n            return;\n          }\n          self.volumes.removeVolumeFromList(vol, targetId);\n        });\n\n        haveChanges = haveChanges || !!deletedVolumes.length;\n      });\n\n      /*= =========  Add new volumes  ========== */\n\n      angular.forEach(volumesFromApi, (volumesFromApi, targetId) => { // eslint-disable-line\n        let addedVolumes;\n\n        if (!self.volumes.volumes[targetId] || !self.volumes.volumes[targetId].length) {\n          addedVolumes = volumesFromApi;\n        } else {\n          addedVolumes = _.filter(\n            volumesFromApi,\n            vol => !_.find(self.volumes.volumes[targetId], { id: vol.id }),\n          );\n        }\n\n        angular.forEach(addedVolumes, (vol) => {\n          // Don't add pending move\n          if (~currentVolumesMovePending.indexOf(vol.id)) {\n            return;\n          }\n          self.volumes.addVolumeToList(vol, targetId);\n        });\n\n        haveChanges = haveChanges || !!addedVolumes.length;\n      });\n\n      if (haveChanges) {\n        $rootScope.$broadcast('infra.refresh.links');\n      }\n\n      return haveChanges;\n    }\n\n    /**\n     *  Triggered by polling: Update volumes list\n     *\n     *  /!\\ take care to don't update all datas, user can be in edition for example.\n     */\n    function updateVolumesFromPolling(volumesParam) {\n      let volumes = volumesParam;\n      let haveChanges = false;\n\n      // Group by attachedTo\n      volumes = _.groupBy(volumes, vol => (vol.attachedTo && vol.attachedTo.length ? vol.attachedTo[0] : 'unlinked'));\n\n      // Update existing Volumes\n      haveChanges = updateVolumesWithVolumesFromApi(volumes, true) || haveChanges;\n      // Add new Volumes, and delete removed Volumes\n      haveChanges = addOrDeleteVolumesWithVolumesFromApi(volumes) || haveChanges;\n\n      if (haveChanges) {\n        self.saveToUserPref();\n      }\n\n      return $q.when(volumes);\n    }\n\n    /**\n     *  --- [Volumes] --- POLLING ---\n     *\n     *  Poll Volumes query\n     */\n    this.pollVolumes = function () {\n      const continueStatus = [\n        'creating',\n        'attaching',\n        'deleting',\n        'extending',\n        'detaching',\n        'snapshotting',\n      ];\n\n      Poller.poll(`/cloud/project/${self.volumes.serviceName}/volume`,\n        null,\n        {\n          successRule(volume) {\n            return !~continueStatus.indexOf(volume.status);\n          },\n          namespace: 'cloud.volumes',\n          notifyOnError: false,\n        }).then((volumes) => {\n        updateVolumesFromPolling(volumes);\n      }, (err) => {\n        if (err && err.status) {\n          console.warn('pollVolumes', err);\n          // @todo add bugkiller here\n        }\n      }, (volumes) => {\n        updateVolumesFromPolling(volumes);\n      });\n    };\n\n    /**\n     *  --- [Volumes] --- POLLING KILL ---\n     *\n     *  Kill the Poll Volumes query\n     */\n    this.killPollVolumes = function () {\n      Poller.kill({ namespace: 'cloud.volumes' });\n    };\n\n    /* -----  End of Polling  ------*/\n\n\n    /*= ===================================\n        =            userPref                =\n        ==================================== */\n\n    this.saveToUserPref = function () {\n      return CloudUserPref.set(`cloud_project_${self.volumes.serviceName}_volumes`,\n        self.volumes.prepareToJson());\n    };\n\n    this.createFromUserPref = function (serviceName) {\n      const key = `cloud_project_${serviceName}_volumes`;\n      return CloudUserPref.get(key).then((volumes) => {\n        _.set(volumes, 'serviceName', serviceName);\n        return new CloudProjectComputeVolumesFactory(volumes);\n      }, () => new CloudProjectComputeVolumesFactory({\n        serviceName,\n      }));\n    };\n\n\n    /*= ===================================================\n    =            LOCAL DATAS UPGRADE (by API)            =\n    ======================================================\n    * =README=\n    * Add, upgrade, and delete VMs or IPs lists with datas from APIs.\n    * Used at initialization, and with polling.\n    **************************************************** */\n\n    /* -----  End of LOCAL DATAS UPGRADE  ------*/\n\n\n    /*= =====================================\n        =            INITIALISATION            =\n        ====================================== */\n\n    /**\n         * Initialize a volumes list, from existing project.\n         */\n    function initExistingProject(opts) {\n      return self.createFromUserPref(opts.serviceName).then((volumesFromCache) => {\n        const initQueue = [];\n\n        self.volumes = volumesFromCache;\n\n        /*= =========  Volumes  ========== */\n\n        initQueue.push(\n          OvhApiCloudProjectVolume.v6().query({\n            serviceName: self.volumes.serviceName,\n          }).$promise.then((volumesParam) => {\n            let volumes = volumesParam;\n\n            // Group by attachedTo\n            volumes = _.groupBy(\n              volumes,\n              vol => (vol.attachedTo && vol.attachedTo.length ? vol.attachedTo[0] : 'unlinked'),\n            );\n\n            // Merge with local datas\n            updateVolumesWithVolumesFromApi(volumes);\n            addOrDeleteVolumesWithVolumesFromApi(volumes, true);\n          }),\n        );\n\n        return $q.all(initQueue).then(() => {\n          // WARNING: Never return promise because pulling had to live on her side\n          self.pollVolumes();\n          return self.volumes;\n        });\n      });\n    }\n\n    /**\n     *  Initialize a new Volumes list, depending of the project's type.\n     */\n    this.init = function (opts) {\n      resetDatas();\n      return initExistingProject(opts);\n    };\n  });\n"]}