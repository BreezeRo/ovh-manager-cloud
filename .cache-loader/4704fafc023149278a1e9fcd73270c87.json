{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/infrastructure/infrastructure-orchestrator.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/components/cloud/project/compute/infrastructure/infrastructure-orchestrator.service.js","mtime":1539717374669},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["/**\n *  Cloud Infrastructure Orchestrator. Beyond it's the sun!\n *  =======================================================\n *\n *  =README=\n *  This orchestrator is used to init and manage a Cloud infrastructure.\n */\nangular.module('managerApp').service('CloudProjectComputeInfrastructureOrchestrator',\n  function ($q, $translate, $rootScope, $timeout, CLOUD_INSTANCE_DEFAULTS, Poller, CloudUserPref,\n    CloudProjectComputeVolumesOrchestrator, CloudProjectComputeInfrastructureFactory,\n    OvhApiCloudProjectInstance, OvhApiCloudProjectIp, OvhApiIp, OvhApiCloudProjectRegion,\n    OvhApiCloudProjectFlavor, OvhApiCloudProjectImage, OvhApiCloudProjectSshKey) {\n    // Warning: all values must be reset at init (see resetDatas())\n    const self = this;\n    let editedVm;\n    let monitoredVm;\n    let paramEdition = null; // type enum {NAME, POWER, OS}\n    const resetDatas = function () {\n      // The full infra to display\n      self.infra = null;\n\n      // Project type (existing, template, template-new)\n      self.serviceType = null;\n\n      // Current edited VM\n      editedVm = null;\n      monitoredVm = null;\n\n      // Stop polling if launched\n      self.killPollVms();\n      self.killPollIps();\n    };\n\n    /*= =========================\n    =            VMs           =\n    ========================== */\n\n    /**\n     * Get the default vm configuration for a specified region\n     */\n    function getDefaultVmConfigurationForRegion(defaultRegion) {\n      const options = {\n        name: $translate.instant('cpci_vm_default_name', { index: self.infra.vrack.getNextIndex() + 1 }),\n        region: defaultRegion,\n      }; const\n        optionsQueue = [];\n\n      // get the flavor id\n      optionsQueue.push(\n        OvhApiCloudProjectFlavor.v6().query({\n          serviceName: self.infra.serviceName,\n        }).$promise.then((flavors) => {\n          _.set(options, 'flavorId', (_.find(flavors, { region: options.region, name: CLOUD_INSTANCE_DEFAULTS.flavor }) || {}).id);\n        }),\n      );\n\n      // get the image id\n      optionsQueue.push(\n        OvhApiCloudProjectImage.v6().query({\n          serviceName: self.infra.serviceName,\n        }).$promise.then((images) => {\n          _.set(options, 'imageId', (_.find(images, { region: options.region, name: CLOUD_INSTANCE_DEFAULTS.image }) || {}).id);\n        }),\n      );\n\n      // get the ssh key id - the first ssh key present in given region\n      // remove this if default image becomes windows type\n      optionsQueue.push(\n        OvhApiCloudProjectSshKey.v6().query({\n          serviceName: self.infra.serviceName,\n        }).$promise.then((sshKeys) => {\n          _.set(options, 'sshKeyId', (_.find(sshKeys, sshKey => sshKey.regions.indexOf(options.region) > -1) || {}).id);\n        }),\n      );\n\n      return $q.allSettled(optionsQueue).then(() => {\n        if (self.infra.vrack.publicCloud && self.infra.vrack.publicCloud.length() > 0) {\n          // use the most recent virtual machine parameters\n          const mostRecentVm = _.last(_.sortBy(self.infra.vrack.publicCloud.items, 'created'));\n          if (mostRecentVm) {\n            if (mostRecentVm.image) {\n              options.imageId = mostRecentVm.image.id;\n            }\n            if (mostRecentVm.flavor) {\n              options.flavorId = mostRecentVm.flavor.id;\n              options.isFlavorSuggested = true;\n            }\n            if (mostRecentVm.region) {\n              options.region = mostRecentVm.region;\n            }\n            if (mostRecentVm.sshKey) {\n              options.sshKeyId = mostRecentVm.sshKey.id;\n            }\n            options.monthlyBillingBoolean = mostRecentVm.monthlyBillingBoolean;\n          }\n        }\n        return options;\n      }, () => options);\n    }\n\n    /**\n     *  Get the default vm configuration options\n     */\n    const getDefaultVmConfiguration = function () {\n      return OvhApiCloudProjectRegion.v6().query({\n        serviceName: self.infra.serviceName,\n      }).$promise.then((regionList) => {\n        // check if the default region exists\n        let { region } = CLOUD_INSTANCE_DEFAULTS;\n        if (_.indexOf(regionList, region) === -1) {\n          region = _.first(regionList);\n        }\n        return getDefaultVmConfigurationForRegion(region);\n      });\n    };\n\n    /**\n     *  Add a virtual machine into project infrastructure\n     */\n    this.addNewVmToList = function (vmOptions) {\n      let vm;\n\n      return $q.when(true).then(() => {\n        if (!vmOptions) {\n          return getDefaultVmConfiguration();\n        }\n        return vmOptions;\n      }).then((options) => {\n        // Add Draft VM to list\n        vm = self.infra.vrack.addVmToPublicCloudList(options);\n        vm.status = 'DRAFT';\n        self.saveToUserPref();\n        return vm;\n      });\n    };\n\n    /**\n     *  Launch the vm creation.\n     */\n    this.saveNewVm = function (vm) {\n      const oldId = vm.id;\n      return vm.launchCreation().then(() => {\n        // we must do it because old id is a fake one\n        self.infra.vrack.publicCloud.replaceItem(oldId, vm);\n        self.saveToUserPref();\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     * Launch vm creation, creating multiple copies.\n     */\n    this.saveMultipleNewVms = function (vmBase, count) {\n      return OvhApiCloudProjectInstance.v6().bulk({\n        serviceName: self.infra.serviceName,\n      }, {\n        flavorId: vmBase.flavor.id,\n        imageId: vmBase.image.id,\n        name: vmBase.name,\n        region: vmBase.region,\n        sshKeyId: vmBase.sshKey ? vmBase.sshKey.id : undefined,\n        monthlyBilling: vmBase.monthlyBillingBoolean,\n        userData: vmBase.userData ? vmBase.userData : undefined,\n        number: count,\n        networks: vmBase.networks,\n      }).$promise.then((vms) => {\n        self.infra.vrack.publicCloud.removeItem(vmBase.id); // remove draft vm\n        self.pollVms(); // updates vm list\n        return vms;\n      });\n    };\n\n    /**\n     *  Set the virtual machine that is currently in edition\n     */\n    this.turnOnVmEdition = function (vm) {\n      editedVm = vm;\n      editedVm.startEdition();\n    };\n\n    /**\n     *  Close/Reset the virtual machine that is currently in edition\n     */\n    this.turnOffVmEdition = function (reset, vmWithChanges) {\n      editedVm.stopEdition(!!reset, vmWithChanges);\n      editedVm = null;\n    };\n\n    /**\n     *  Open monitoring panel\n     */\n    this.openMonitoringPanel = function (vm) {\n      monitoredVm = vm;\n      vm.startMonitoring();\n    };\n\n    this.getMonitoredVm = function () {\n      return monitoredVm;\n    };\n\n    /**\n     *  Get the virtual machine that is currently in edition\n     */\n    this.getEditedVm = function () {\n      return editedVm;\n    };\n\n    /**\n     *  Get parameters for current edition\n     */\n    this.getEditVmParam = function () {\n      return paramEdition;\n    };\n\n    /**\n     *  Get parameters for current edition\n     */\n    this.setEditVmParam = function (param) {\n      paramEdition = param;\n    };\n\n    /**\n     *  Save the VM modifications\n     */\n    this.saveEditedVm = function (vm) {\n      return vm.edit().then(() => {\n        self.saveToUserPref();\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     *  Delete VM\n     */\n    this.deleteVm = function (vm) {\n      if (vm.status === 'DRAFT') {\n        return $q.when(true).then(() => {\n          self.infra.vrack.removeVmFromPublicCloudList(vm);\n          self.refreshLinks();\n          self.saveToUserPref();\n        });\n      }\n      return vm.remove().then(() => {\n        self.saveToUserPref();\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     *  Rescue VM\n     */\n    this.rescueVm = function (vm, enable, image) {\n      return vm.rescueMode(enable, image).then((result) => {\n        self.pollVms();\n        return result;\n      });\n    };\n\n    /**\n     *  Reboot [soft|hard] VM\n     */\n    this.rebootVm = function (vm, type) {\n      return vm.reboot(type).then(() => {\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     *  Resume VM\n     */\n    this.resumeVm = function (vm) {\n      return vm.resume().then(() => {\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     *  Reinstall VM\n     */\n    this.reinstallVm = function (vm) {\n      return vm.reinstall().then(() => {\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     *  Create a new snapshot of VM\n     */\n    this.backupVm = function (vm, snapshotName) {\n      return vm.backup(snapshotName).then(() => {\n        self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n      });\n    };\n\n    /**\n     *  Collapse all vm\n     */\n    this.collapseAllVm = function () {\n      this.infra.vrack.collapseAll();\n      this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n    };\n\n    /**\n     *  Uncollapse all vm\n     */\n    this.uncollapseAllVm = function () {\n      this.infra.vrack.uncollapseAll();\n      this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n    };\n\n    /**\n     *  Toggle the collapsed state of given vm and save to userPref\n     */\n    this.toggleVmCollapsedState = function (vm) {\n      _.set(vm, 'collapsed', !vm.collapsed);\n      this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n      return $q.when(vm);\n    };\n\n    /**\n     *  Toggle the collapsed state of given vm and save to userPref\n     */\n    this.toggleCollapsedVolumes = function (vm) {\n      _.set(vm, 'collapsedVolumes', !vm.collapsedVolumes);\n      this.saveToUserPref(); // ------ TODO: dangerous, this do an ASYNC call\n      return $q.when(vm);\n    };\n\n    this.loadVmMonitoringData = function () {\n      _.each(this.infra.vrack.publicCloud.items, (instance) => {\n        instance.getMonitoringData();\n      });\n    };\n\n    /* -----  End of VMs  ------*/\n\n    /*= =========================\n     =         VLANs           =\n     ========================== */\n\n    this.hasVrack = function () {\n      return this.infra.vlan.hasVrack();\n    };\n\n    /*= =========================\n    =            IP            =\n    ========================== */\n\n    /**\n     * Attach an IP to a VM\n     */\n    this.attachIptoVm = function (ip, vm) {\n      if (ip.status === 'DRAFT') {\n        // @todo\n        return $q.when('TODO').then(() => {\n          self.saveToUserPref();\n        });\n      }\n      return ip.attach(vm.id).then(() => {\n        switch (ip.type) {\n          case 'failover':\n            // WARNING: Never return promise because pulling had to live on her side\n            self.pollIps(ip.type);\n            break;\n          default:\n            break;\n        }\n        // @todo: other types\n      });\n    };\n\n    function rearrangeIpv6(instance) {\n      const publicIpV4Index = _.findIndex(instance.ipAddresses, { version: 4, type: 'public' });\n      const publicIpV6Index = _.findIndex(instance.ipAddresses, { version: 6, type: 'public' });\n\n      if (publicIpV4Index !== -1 && publicIpV6Index !== -1) {\n        instance.ipAddresses[publicIpV4Index].ipV6 = { ip: instance.ipAddresses[publicIpV6Index].ip, gateway: instance.ipAddresses[publicIpV6Index].gatewayIp }; // eslint-disable-line\n        instance.ipAddresses.splice(publicIpV6Index, 1);\n      }\n    }\n\n    /**\n     *  Get list of IPs Public (from the list of VMs)\n     */\n    function getPublicIpAddressesFromInstances(vms) {\n      const publicIpAddresses = [];\n      angular.forEach(vms, (vm) => {\n        rearrangeIpv6(vm);\n\n        angular.forEach(_.filter(vm.ipAddresses, { type: 'public' }), (publicIpAddress) => {\n          _.set(publicIpAddress, 'id', publicIpAddress.ip);\n          _.set(publicIpAddress, 'routedTo', vm.id);\n          publicIpAddresses.push(publicIpAddress);\n        });\n      });\n      return publicIpAddresses;\n    }\n\n    /**\n     *  Make the links between VMs and IPs\n     */\n    this.refreshLinks = function () {\n      angular.forEach(self.infra.internet.ipList.items, (ip) => {\n        self.infra.refreshVmsRoutedToFromIp(ip);\n      });\n      $rootScope.$broadcast('infra.refresh.links');\n    };\n\n    /* -----  End of IPs  ------*/\n\n\n    /*= ==============================\n    =            POLLING            =\n    =============================== */\n\n    /**\n     *  --- [IPs] --- [update] ---\n     *\n     * Updates instances from API with instances from this factory\n     *  /!\\ This don't add or remove instances!\n     */\n    function updateIpsWithIpsFromApi(ipsFromApi) {\n      angular.forEach(ipsFromApi, (ipFromApi) => {\n        const ipFromFactory = self.infra.internet.getIpById(ipFromApi.id);\n        if (!ipFromFactory) {\n          return;\n        }\n        ipFromFactory.setInfos(ipFromApi);\n      });\n    }\n\n    /**\n     *  --- [IPs] --- [addOrDelete] ---\n     *\n     *  Add or remove IPs from API with IPs from this factory\n     *  /!\\ This can't update existing datas!!!\n     */\n    function addOrDeleteIpsWithIpsFromApi(ipsFromApi, type, forceRemoveDrafts) {\n      /*= =========  Remove deleted IPs  ========== */\n\n      const deletedIps = _.filter(self.infra.internet.ipList.items, (ip) => {\n        // don't remove drafts!\n        if (ip.type !== type || (!forceRemoveDrafts && ip.status === 'DRAFT')) {\n          return false;\n        }\n        return !_.find(ipsFromApi, { id: ip.id });\n      });\n\n      angular.forEach(deletedIps, (ip) => {\n        self.infra.internet.removeIpFromList(ip);\n      });\n\n      /*= =========  Add new IPs  ========== */\n\n      const addedIps = _.filter(ipsFromApi, ip => !self.infra.internet.getIpById(ip.id));\n      angular.forEach(addedIps, (ip) => {\n        _.set(ip, 'type', type);\n        ip = self.infra.internet.addIpToList(ip); // eslint-disable-line\n      });\n\n      // return true if updated\n      return !!(deletedIps.length || addedIps.length);\n    }\n\n    /**\n     *  Triggered by polling: Update IPs list\n     *\n     *  /!\\ take care to don't update all datas, user can be in edition for example.\n     */\n    function updateIpsFromPolling(ips, type) {\n      let haveChanges = false;\n\n      // Update existing IPs\n      haveChanges = updateIpsWithIpsFromApi(ips, type) || haveChanges;\n      // Add new IPs, and delete removed IPs\n      haveChanges = addOrDeleteIpsWithIpsFromApi(ips, type) || haveChanges;\n\n      self.refreshLinks();\n\n      if (haveChanges) {\n        self.saveToUserPref();\n      }\n      return $q.when(ips);\n    }\n\n    /**\n     *  --- [VMs] --- [update] ---\n     *\n     * Updates instances from API with instances from this factory\n     *  /!\\ This don't add or remove instances!\n     */\n    function updateInstancesWithInstancesFromApi(instancesFromApi, updateOnlySpecificDatas) {\n      let haveChanges = false;\n\n      angular.forEach(instancesFromApi, (instanceFromApi) => {\n        const instanceFromFactory = self.infra.vrack.getVmById(instanceFromApi.id);\n\n\n        const currentEditedVm = self.getEditedVm();\n\n        if (!instanceFromFactory) {\n          return;\n        }\n\n        if (updateOnlySpecificDatas) {\n          // Update status\n          if (instanceFromFactory.status !== instanceFromApi.status) {\n            const oldStatus = instanceFromFactory.status;\n            const hardRebootingSuspended = instanceFromFactory.status === 'HARD_REBOOT' && instanceFromApi.status === 'SUSPENDED';\n            // if hard rebooting a suspended project the API do not update the status correctly\n            // this bug is not easilly fixable for the API so we fix it on UX side\n            if (!hardRebootingSuspended) {\n              haveChanges = true;\n              instanceFromFactory.status = instanceFromApi.status;\n              $rootScope.$broadcast('compute.infrastructure.vm.status-update', instanceFromApi.status, oldStatus, instanceFromFactory);\n            }\n          }\n\n          // Update this datas ONLY if vm is not in edition\n          if (!currentEditedVm || (currentEditedVm\n              && currentEditedVm.id\n              && currentEditedVm.id !== instanceFromApi.id)) {\n            // Update image reinstall\n            if (instanceFromApi.imageId\n                && instanceFromFactory.image\n                && instanceFromFactory.image.id\n                && instanceFromApi.imageId !== instanceFromFactory.image.id) {\n              instanceFromFactory.imageId = instanceFromApi.imageId;\n              instanceFromFactory.getFullInformations();\n              haveChanges = true;\n            }\n\n            // Update flavor upscaling\n            if (instanceFromApi.flavorId\n              && instanceFromFactory.flavor\n              && instanceFromFactory.flavor.id\n              && instanceFromApi.flavorId !== instanceFromFactory.flavor.id) {\n              instanceFromFactory.flavorId = instanceFromApi.flavorId;\n              instanceFromFactory.getFullInformations();\n              haveChanges = true;\n            }\n          }\n\n          // Update ipAddresses array\n          if (instanceFromApi.ipAddresses\n            && instanceFromApi.ipAddresses.length\n            && (!instanceFromFactory.ipAddresses\n              || (instanceFromFactory.ipAddresses.length !== instanceFromApi.ipAddresses.length))) {\n            instanceFromFactory.ipAddresses = instanceFromApi.ipAddresses;\n            haveChanges = true;\n          }\n\n          // Update monthlyBilling\n          if (!instanceFromFactory.monthlyBilling && instanceFromApi.monthlyBilling) {\n            haveChanges = true;\n            instanceFromFactory.monthlyBilling = angular.copy(instanceFromApi.monthlyBilling);\n          }\n\n          // Update monthlyBilling status\n          if (instanceFromFactory.monthlyBilling\n              && instanceFromApi.monthlyBilling\n              && instanceFromFactory.monthlyBilling.status !== instanceFromApi\n                .monthlyBilling.status) {\n            haveChanges = true;\n            const oldStatus = instanceFromFactory.monthlyBilling.status;\n            instanceFromFactory.monthlyBilling.status = instanceFromApi.monthlyBilling.status;\n            $rootScope.$broadcast('compute.infrastructure.vm.monthlyBilling.status-update', instanceFromApi.status, oldStatus, instanceFromFactory);\n          }\n        } else {\n          // Updates all infos\n          instanceFromFactory.setInfos(instanceFromApi);\n          haveChanges = true;\n        }\n      });\n\n      return haveChanges;\n    }\n\n    /*= ===================================================\n      =            LOCAL DATAS UPGRADE (by API)            =\n      ======================================================\n      * =README=\n      * Add, upgrade, and delete VMs or IPs lists with datas from APIs.\n      * Used at initialization, and with polling.\n      **************************************************** */\n\n    /**\n     *  --- [VMs] --- [addOrDelete] ---\n     *\n     *  Add or remove instances from API with instances from this factory\n     *  /!\\ This can't update existing datas!!!\n     */\n    function addOrDeleteInstancesWithInstancesFromApi(instancesFromApi, forceRemoveDrafts) {\n      /*= =========  Remove deleted instances  ========== */\n\n      const deletedInstances = _.filter(self.infra.vrack.publicCloud.items, (vm) => {\n        // don't remove drafts!\n        if (!forceRemoveDrafts && vm.status === 'DRAFT') {\n          return false;\n        }\n        const instance = _.find(instancesFromApi, { id: vm.id });\n        return !instance || instance.status === 'DELETED';\n      });\n\n      angular.forEach(deletedInstances, (vm) => {\n        self.infra.vrack.removeVmFromPublicCloudList(vm);\n      });\n\n      /*= =========  Add new instances  ========== */\n\n      const addedInstances = _.filter(instancesFromApi, vm => vm.status !== 'DELETED' && !self.infra.vrack.getVmById(vm.id));\n      angular.forEach(addedInstances, (vm) => {\n        self.infra.vrack.addVmToPublicCloudList(vm);\n      });\n\n      // return true if updated\n      return !!(deletedInstances.length || addedInstances.length);\n    }\n\n    /* -----  End of LOCAL DATAS UPGRADE  ------*/\n    /**\n     *  Triggered by polling: Update instances list\n     *\n     *  /!\\ take care to don't update all datas, user can be in edition for example.\n     */\n    function updateInstancesFromPolling(instances) {\n      let haveChanges = false;\n\n      // Update existing VMs\n      haveChanges = updateInstancesWithInstancesFromApi(instances, true) || haveChanges;\n      // Add new VMs, and delete removed VMs\n      haveChanges = addOrDeleteInstancesWithInstancesFromApi(instances) || haveChanges;\n\n      // Public IPs are into the instance infos, so we need to took them\n      const publicIpAddresses = getPublicIpAddressesFromInstances(instances);\n      updateIpsWithIpsFromApi(publicIpAddresses, 'public');\n      addOrDeleteIpsWithIpsFromApi(publicIpAddresses, 'public');\n\n      self.refreshLinks();\n\n      if (haveChanges) {\n        self.saveToUserPref();\n        CloudProjectComputeVolumesOrchestrator.pollVolumes(); // [async]\n      }\n      return $q.when(instances);\n    }\n\n    /**\n     *  --- [VMs] --- POLLING ---\n     *\n     *  Poll VM query\n     */\n    this.pollVms = function () {\n      const continueStatus = [\n        'DELETING',\n        'BUILDING',\n        'HARD_REBOOT',\n        'REBOOT',\n        'REBUILD',\n        'REVERT_RESIZE',\n        'VERIFY_RESIZE',\n        'MIGRATING',\n        'RESIZE',\n        'BUILD',\n        'RESCUING',\n        'UNRESCUING',\n        'RESCUE',\n        'SNAPSHOTTING',\n        'RESUMING',\n      ];\n\n      Poller.poll(`/cloud/project/${self.infra.serviceName}/instance`,\n        null,\n        {\n          successRule(vm) {\n            return (!vm.monthlyBilling || (vm.monthlyBilling && vm.monthlyBilling.status !== 'activationPending'))\n              && (_.every(continueStatus, continueState => vm.status !== continueState));\n          },\n          namespace: 'cloud.infra.vms',\n          notifyOnError: false,\n        }).then((vms) => {\n        updateInstancesFromPolling(vms);\n      }, (err) => {\n        if (err && err.status) {\n          console.warn('pollVms', err);\n          // @todo add bugkiller here\n        }\n      }, (vms) => {\n        updateInstancesFromPolling(vms);\n      });\n    };\n\n    /**\n     *  --- [VMs] --- POLLING KILL ---\n     *\n     *  Kill the Poll VM query\n     */\n    this.killPollVms = function () {\n      Poller.kill({ namespace: 'cloud.infra.vms' });\n    };\n\n    // ---\n\n    /**\n     *  --- [IPs] --- POLLING ---\n     *\n     *  Poll IPs list\n     *  [ip] : the type of the IPs\n     */\n    this.pollIps = function (type) {\n      return Poller.poll(`/cloud/project/${self.infra.serviceName}/ip/${type}`,\n        null,\n        {\n          successRule(ip) {\n            return ip.status === 'ok';\n          },\n          namespace: 'cloud.infra.ips',\n        }).then((ips) => {\n        updateIpsFromPolling(ips, type);\n      }, (err) => {\n        if (err && err.status) {\n          console.warn('pollIps', err);\n          // @todo add bugkiller here\n        }\n      }, (ips) => {\n        updateIpsFromPolling(ips, type);\n      });\n    };\n\n    /**\n     *  --- [IPs] --- POLLING KILL ---\n     *\n     *  Kill the Poll IPs query\n     */\n    this.killPollIps = function () {\n      Poller.kill({ namespace: 'cloud.infra.ips' });\n    };\n\n    /* -----  End of Polling  ------*/\n\n\n    /*= ===================================\n    =            UserPref            =\n    ==================================== */\n\n    this.saveToUserPref = function () {\n      return CloudUserPref.set(`cloud_project_${self.infra.serviceName}_infra`,\n        self.infra.prepareToJson());\n    };\n\n    this.createFromUserPref = function (serviceName) {\n      const key = `cloud_project_${serviceName}_infra`;\n      return CloudUserPref.get(key).then((infra) => {\n        _.set(infra, 'serviceName', serviceName);\n        return new CloudProjectComputeInfrastructureFactory(infra);\n      }, () => new CloudProjectComputeInfrastructureFactory({\n        serviceName,\n      }));\n    };\n\n    /**\n     * Initialize an infrastructure\n     */\n    function initExistingProject(opts) {\n      return self.createFromUserPref(opts.serviceName).then((infraFromUserPref) => {\n        const initQueue = [];\n\n        self.infra = infraFromUserPref;\n\n        /*= =========  VMs  ========== */\n\n        initQueue.push(\n          OvhApiCloudProjectInstance.v6().query({\n            serviceName: self.infra.serviceName,\n          }).$promise.then((instances) => {\n            _.forEach(instances, (instance) => {\n              rearrangeIpv6(instance);\n            });\n\n            // Merge with local datas\n            updateInstancesWithInstancesFromApi(instances);\n            addOrDeleteInstancesWithInstancesFromApi(instances, true);\n\n            // Public IPs are into the instance infos, so we need to took them\n            const publicIpAddresses = getPublicIpAddressesFromInstances(instances);\n            updateIpsWithIpsFromApi(publicIpAddresses, 'public');\n            addOrDeleteIpsWithIpsFromApi(publicIpAddresses, 'public', true);\n          }),\n        );\n\n        /*= =========  IPs  ========== */\n\n        const ipTypes = ['failover'];\n        angular.forEach(ipTypes, (ipType) => {\n          initQueue.push(\n            OvhApiCloudProjectIp[ipType].v6().query({\n              serviceName: self.infra.serviceName,\n            }).$promise.then((ips) => {\n              angular.forEach(ips, (ip) => {\n                _.set(ip, 'type', ipType);\n              });\n              return ips;\n            }).then((ips) => {\n              // Merge with local datas\n              updateIpsWithIpsFromApi(ips, ipType);\n              addOrDeleteIpsWithIpsFromApi(ips, ipType, true);\n            }),\n          );\n        });\n\n        return $q.all(initQueue).then(() => {\n          self.refreshLinks();\n          self.pollVms(); // WARNING: Never return promise because pulling had to live on her side\n          self.pollIps('failover'); // WARNING: Never return promise because pulling had to live on her side\n          return self.infra;\n        });\n      });\n    }\n\n    /**\n     *  Initialize a new Infrastructure\n     */\n    this.init = function (opts) {\n      resetDatas();\n      return initExistingProject(opts);\n    };\n  });\n"]}