{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/vrack/vrack.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/vrack/vrack.controller.js","mtime":1539717142312},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["angular.module('managerApp').controller('VrackCtrl',\n  function VrackCtrl($scope, $q, $stateParams, $state, $timeout, $translate, $uibModal,\n    CloudMessage, SidebarMenu, OvhApiVrack, OvhApiCloudProject, OvhApiMe, URLS, VrackService) {\n    const self = this;\n    const pollingInterval = 5000;\n\n    self.poller = null;\n    self.serviceName = null;\n    self.name = null;\n    self.description = null;\n    self.nameEditing = false;\n    self.descriptionEditing = false;\n    self.nameOptions = { pattern: /^([a-zA-Z])\\S*$/, maxLength: 100 };\n    self.descriptionOptions = { maxLength: 255 };\n    self.changeOwnerUrl = null;\n    self.vRackCloudRoadmapGuide = null;\n    self.vrackService = VrackService;\n\n    self.modals = {\n      move: null,\n    };\n\n    self.messages = [];\n\n    self.loaders = {\n      init: false,\n      adding: false,\n      deleting: false,\n      moving: false,\n    };\n\n    self.data = {\n      cloudProjects: [],\n      allowedServices: {},\n      vrackServices: {},\n      pendingTasks: [],\n    };\n\n    self.form = {\n      servicesToAdd: [],\n      servicesToDelete: [],\n      serviceToMove: null,\n    };\n\n    self.states = {\n      accordions: {\n        available: {\n          types: [],\n          groups: [],\n          dedicatedCloudNetworks: [],\n        },\n        mapped: {\n          types: [],\n          groups: [],\n          dedicatedCloudNetworks: [],\n          dedicatedCloudDatacenters: [],\n        },\n      },\n    };\n    self.refreshMessage = function () {\n      self.messages = self.messageHandler.getMessages();\n    };\n\n    self.loadMessage = function () {\n      CloudMessage.unSubscribe('vrack');\n      self.messageHandler = CloudMessage.subscribe('vrack', { onMessage: () => self.refreshMessage() });\n    };\n\n    self.groupedServiceKeys = {\n      dedicatedCloudDatacenter: 'dedicatedCloud.niceName',\n      dedicatedServerInterface: 'dedicatedServer.niceName',\n    };\n\n    self.getDisplayName = function (serviceType) {\n      return $translate.instant(`vrack_service_type_${serviceType.toLowerCase()}`);\n    };\n\n    function getDedicatedServerNiceName(service) {\n      const formattedService = {};\n      angular.copy(service, formattedService);\n      formattedService.id = service.name;\n      // by default the reverse seem to be equal to the name,\n      // so do not display redondant information.\n      if (service.reverse && service.reverse !== service.name) {\n        formattedService.niceName = `${service.name} (${service.reverse})`;\n      } else {\n        formattedService.niceName = service.name;\n      }\n      formattedService.trueServiceType = 'dedicatedServer';\n      return formattedService;\n    }\n\n    function getDedicatedServerInterfaceNiceName(service) {\n      const formattedService = getDedicatedServerNiceName(service.dedicatedServer);\n      formattedService.id = service.dedicatedServerInterface;\n      formattedService.niceName = `${formattedService.niceName} - ${service.name}`;\n      formattedService.trueServiceType = 'dedicatedServerInterface';\n      return formattedService;\n    }\n\n    function getDedicatedCloudNiceName(service) {\n      const formattedService = {};\n      angular.copy(service, formattedService);\n      formattedService.id = service.serviceName;\n      if (service.description) {\n        formattedService.niceName = `${service.serviceName} (${service.description})`;\n      } else {\n        formattedService.niceName = service.serviceName;\n      }\n      formattedService.trueServiceType = 'dedicatedCloud';\n      return formattedService;\n    }\n\n    function getCloudProjectNiceName(service) {\n      const formattedService = {};\n      angular.copy(service, formattedService);\n      formattedService.id = service.project_id;\n      if (service.description) {\n        formattedService.niceName = service.description;\n      } else {\n        formattedService.niceName = service.project_id;\n      }\n      formattedService.trueServiceType = 'cloudProject';\n      return formattedService;\n    }\n\n    function getIpLoadbalancingNiceName(service) {\n      const formattedService = {};\n      angular.copy(service, formattedService);\n      formattedService.id = service.serviceName;\n      if (service.displayName) {\n        formattedService.niceName = service.displayName;\n      } else {\n        formattedService.niceName = service.serviceName;\n      }\n      formattedService.trueServiceType = 'ipLoadbalancing';\n      return formattedService;\n    }\n\n    function fillServiceData(serviceType, service) {\n      let formattedService = null;\n      switch (serviceType) {\n        case 'dedicatedServer':\n          formattedService = getDedicatedServerNiceName(service);\n          break;\n        case 'dedicatedServerInterface':\n          formattedService = getDedicatedServerInterfaceNiceName(service);\n          break;\n        case 'dedicatedCloud':\n          formattedService = getDedicatedCloudNiceName(service);\n          break;\n        case 'dedicatedCloudDatacenter':\n          formattedService = _.cloneDeep(service);\n          formattedService.id = service.datacenter;\n          formattedService.niceName = _.last(service.datacenter.split('_'));\n          if (_.isObject(service.dedicatedCloud)) {\n            formattedService.dedicatedCloud.niceName = `${service.dedicatedCloud.serviceName} (${service.dedicatedCloud.description})`;\n          } else {\n            formattedService.dedicatedCloud = {\n              niceName: service.dedicatedCloud,\n            };\n          }\n          formattedService.trueServiceType = 'dedicatedCloudDatacenter';\n          break;\n        case 'legacyVrack':\n          formattedService = {\n            id: service,\n            niceName: service,\n            trueServiceType: 'legacyVrack',\n          };\n          break;\n        case 'ip':\n          formattedService = {\n            id: service,\n            niceName: service,\n            trueServiceType: 'ip',\n          };\n          break;\n        case 'cloudProject':\n          formattedService = getCloudProjectNiceName(service);\n          break;\n        case 'ipLoadbalancing':\n          formattedService = getIpLoadbalancingNiceName(service);\n          break;\n        default:\n          formattedService = _.cloneDeep(service);\n          break;\n      }\n      return formattedService;\n    }\n\n    self.getAllowedServices = function () {\n      return OvhApiVrack.Aapi().allowedServices({ serviceName: self.serviceName }).$promise\n        .then((allServicesParam) => {\n          let allServices = allServicesParam;\n          allServices = _.mapValues(allServices, (services, serviceType) => {\n            if (_.isArray(services)) {\n              return _.map(services, service => fillServiceData(serviceType, service));\n            }\n            return services;\n          });\n\n          // We need to append dedicatedServerInterfaces list to dedicatedServers list.\n          if (_.has(allServices, 'dedicatedServerInterface') && allServices.dedicatedServerInterface.length > 0) {\n            // If dedicatedServers list doesn't exist, we create it first.\n            if (!_.has(allServices, 'dedicatedServer')) {\n              allServices.dedicatedServer = [];\n            }\n\n            angular.forEach(allServices.dedicatedServerInterface, (serverInterface) => {\n              allServices.dedicatedServer.push(serverInterface);\n            });\n\n            allServices.dedicatedServerInterface = [];\n          }\n\n          return allServices;\n        });\n    };\n\n    self.getVrackServices = function () {\n      return OvhApiVrack.Aapi().services({ serviceName: self.serviceName }).$promise\n        .then((allServicesParam) => {\n          let allServices = allServicesParam;\n          allServices = _.mapValues(allServices, (servicesParams, serviceType) => {\n            let services = servicesParams;\n            if (_.isArray(services)) {\n              services = _.map(services, service => fillServiceData(serviceType, service));\n            }\n            return services;\n          });\n\n          if (_.has(allServices, 'dedicatedCloudDatacenter')) {\n            allServices.dedicatedCloudDatacenter = _.groupBy(\n              allServices.dedicatedCloudDatacenter,\n              self.groupedServiceKeys.dedicatedCloudDatacenter,\n            );\n          }\n\n          // We need to append dedicatedServerInterfaces list to dedicatedServers list.\n          if (_.has(allServices, 'dedicatedServerInterface') && allServices.dedicatedServerInterface.length > 0) {\n            // If dedicatedServers list doesn't exist, we create it first.\n            if (!_.has(allServices, 'dedicatedServer')) {\n              allServices.dedicatedServer = [];\n            }\n\n            angular.forEach(allServices.dedicatedServerInterface, (serverInterface) => {\n              allServices.dedicatedServer.push(serverInterface);\n            });\n\n            allServices.dedicatedServerInterface = [];\n          }\n\n          return allServices;\n        });\n    };\n\n    self.getPendingTasks = function () {\n      return OvhApiVrack.v6()\n        .tasks({\n          serviceName: self.serviceName,\n        }).$promise\n        .then(taskIds => $q.all(_.map(taskIds, id => OvhApiVrack.v6()\n          .task({\n            serviceName: self.serviceName,\n            taskId: id,\n          }).$promise\n          .then(task => task)\n          .catch(err => (err.status === 404 ? $q.when(null) : $q.reject(err)))))\n          .then(tasks => _.without(tasks, null)));\n    };\n\n    self.resetCache = function () {\n      OvhApiVrack.v6().resetCache();\n      OvhApiVrack.CloudProject().v6().resetQueryCache();\n      OvhApiVrack.IpLoadBalancing().v6().resetQueryCache();\n      OvhApiVrack.DedicatedCloud().v6().resetQueryCache();\n      OvhApiVrack.DedicatedServer().v6().resetQueryCache();\n      OvhApiVrack.DedicatedServerInterface().v6().resetQueryCache();\n      OvhApiVrack.Ip().v6().resetQueryCache();\n      OvhApiVrack.LegacyVrack().v6().resetQueryCache();\n      OvhApiVrack.Aapi().resetAllCache();\n    };\n\n    self.moveDisplayedService = function (serviceId, allServicesSource, allServicesDestination) {\n      let serviceToMove = null;\n      let typeToMove = null;\n      let isGroupedServicesType = false;\n      _.forEach(allServicesSource, (services, type) => {\n        const servicesToSearch = !_.isArray(allServicesSource[type])\n          ? _.flatten(_.values(allServicesSource[type]))\n          : allServicesSource[type];\n\n        serviceToMove = _.remove(servicesToSearch, (service) => {\n          if (service.id === serviceId) {\n            typeToMove = type;\n            isGroupedServicesType = !_.isArray(allServicesSource[type]);\n            return true;\n          }\n          return null;\n        });\n\n        if (!_.isEmpty(serviceToMove)) {\n          if (isGroupedServicesType) {\n            allServicesSource[typeToMove] = _.groupBy(servicesToSearch, self.groupedServiceKeys[typeToMove]); // eslint-disable-line\n          } else {\n            allServicesSource[typeToMove] = servicesToSearch; // eslint-disable-line\n          }\n\n          return false;\n        }\n        return null;\n      });\n\n      if (serviceToMove && typeToMove) {\n        if (isGroupedServicesType) {\n          const services = _.flatten(_.values(allServicesDestination[typeToMove]));\n          services.push(serviceToMove[0]);\n          allServicesDestination[typeToMove] = _.groupBy(services, self.groupedServiceKeys[typeToMove]); // eslint-disable-line\n        } else {\n          allServicesDestination[typeToMove].push(serviceToMove[0]);\n        }\n      }\n    };\n\n    self.refreshData = function () {\n      let poll = true;\n      return self.getPendingTasks().then((tasks) => {\n        /**\n             * First, we check if there is any new pending tasks ...\n             */\n        const currentTasks = _.pluck(tasks, 'id');\n        const previousTasks = _.pluck(self.data.pendingTasks, 'id');\n        if (_.difference(currentTasks, previousTasks).length\n          || _.difference(previousTasks, currentTasks).length) {\n          self.resetCache(); // a task changed, vrack state might have changed too\n        } else if (tasks.length === 0) {\n          poll = false; // no new tasks & no tasks, no need to poll\n        }\n        /**\n             * Secondly, we fetch vrack data ...\n             */\n        return $q.all({\n          allowedServices: self.getAllowedServices(),\n          vrackServices: self.getVrackServices(),\n        }).then((result) => {\n          self.data.pendingTasks = tasks;\n          self.data.allowedServices = result.allowedServices;\n          self.data.vrackServices = result.vrackServices;\n\n          /**\n                 * Finally, check if some tasks are adding or removing services in vrack\n                 * and move the service in his \"future\" column\n                 */\n          angular.forEach(self.data.pendingTasks, (task) => {\n            if (task && task.targetDomain) {\n              const id = task.targetDomain;\n              const fn = task.function;\n              if (_.startsWith(fn, 'add')) {\n                self.moveDisplayedService(id, self.data.allowedServices, self.data.vrackServices);\n              } else if (_.startsWith(fn, 'remove')) {\n                self.moveDisplayedService(id, self.data.vrackServices, self.data.allowedServices);\n              }\n              self.form.servicesToAdd = _.reject(self.form.servicesToAdd, { id });\n              self.form.servicesToDelete = _.reject(self.form.servicesToDelete, { id });\n            }\n          });\n        });\n      }).finally(() => {\n        // if there are some pending tasks, poll\n        if (poll && !self.poller) {\n          self.poller = $timeout(() => {\n            self.poller = null;\n            self.refreshData();\n          }, pollingInterval);\n        }\n        self.loaders.init = false;\n      });\n    };\n\n    self.isSelected = function (serviceType, serviceId) {\n      return angular.isDefined(_.find(self.form.servicesToAdd, {\n        type: serviceType,\n        id: serviceId,\n      }))\n       || angular.isDefined(_.find(self.form.servicesToDelete, {\n         type: serviceType,\n         id: serviceId,\n       }))\n       || _.isEqual(self.form.serviceToMove, { type: serviceType, id: serviceId });\n    };\n\n    self.isPending = function (serviceId) {\n      const ids = _.uniq(_.pluck(self.data.pendingTasks, 'targetDomain'));\n      return ids.indexOf(serviceId) >= 0;\n    };\n\n    self.toggleAddService = function (serviceType, serviceId) {\n      if (!self.isPending(serviceId) && !self.loaders.adding && !self.loaders.deleting) {\n        const toAdd = { type: serviceType, id: serviceId };\n        if (_.find(self.form.servicesToAdd, toAdd)) {\n          self.form.servicesToAdd = _.reject(self.form.servicesToAdd, toAdd);\n        } else {\n          self.form.servicesToAdd.push(toAdd);\n        }\n        self.form.serviceToMove = null;\n        self.form.servicesToDelete = [];\n      }\n    };\n\n    self.toggleDeleteService = function (serviceType, serviceId) {\n      if (!self.isPending(serviceId) && !self.loaders.adding && !self.loaders.deleting) {\n        const toDelete = { type: serviceType, id: serviceId };\n        if (_.find(self.form.servicesToDelete, toDelete)) {\n          self.form.servicesToDelete = _.reject(self.form.servicesToDelete, toDelete);\n        } else {\n          self.form.servicesToDelete.push(toDelete);\n        }\n        self.form.serviceToMove = null;\n        self.form.servicesToAdd = [];\n      }\n    };\n\n    self.toggleMoveService = function (serviceType, serviceId) {\n      if (self.isPending(serviceId) || self.loaders.moving) {\n        return;\n      }\n      const toMove = { type: serviceType, id: serviceId };\n      if (self.form.serviceToMove === null) {\n        self.form.servicesToAdd = [];\n        self.form.servicesToDelete = [];\n        self.form.serviceToMove = toMove;\n      } else {\n        self.form.serviceToMove = null;\n      }\n    };\n\n    self.editName = function () {\n      self.nameEditing = true;\n      self.nameBackup = self.name;\n    };\n\n    self.cancelEditName = function () {\n      self.nameEditing = false;\n      self.name = self.nameBackup;\n    };\n\n    self.saveName = function () {\n      self.nameEditing = false;\n\n      OvhApiVrack.v6().edit({ serviceName: self.serviceName }, { name: self.name }).$promise\n        .catch((err) => {\n          self.name = self.nameBackup;\n          CloudMessage.error([$translate.instant('vrack_error'), (err.data && err.data.message) || err.message || ''].join(' '));\n        })\n        .finally(() => {\n          const menuItem = SidebarMenu.getItemById(self.serviceName);\n          if (menuItem) {\n            menuItem.title = self.name || self.serviceName;\n          }\n          self.nameBackup = null;\n        });\n    };\n\n    self.editDescription = function () {\n      self.descriptionEditing = true;\n      self.descriptionBackup = self.description;\n    };\n\n    self.cancelEditDescription = function () {\n      self.descriptionEditing = false;\n      self.description = self.descriptionBackup;\n    };\n\n    self.saveDescription = function () {\n      self.descriptionEditing = false;\n      OvhApiVrack.v6()\n        .edit({ serviceName: self.serviceName }, { description: self.description }).$promise\n        .catch((err) => {\n          self.description = self.descriptionBackup;\n          CloudMessage.error([$translate.instant('vrack_error'), (err.data && err.data.message) || err.message || ''].join(' '));\n        })\n        .finally(() => {\n          self.descriptionBackup = null;\n        });\n    };\n\n    self.addSelectedServices = function () {\n      self.loaders.adding = true;\n      return $q.all(_.map(self.form.servicesToAdd, (service) => {\n        let task = $q.reject('Unknown service type');\n        switch (service.type) {\n          case 'dedicatedServer':\n            task = OvhApiVrack.DedicatedServer().v6().create({\n              serviceName: self.serviceName,\n            }, {\n              dedicatedServer: service.id,\n            }).$promise;\n            break;\n          case 'dedicatedServerInterface':\n            task = OvhApiVrack.DedicatedServerInterface().v6().post({\n              serviceName: self.serviceName,\n            }, {\n              dedicatedServerInterface: service.id,\n            }).$promise;\n            break;\n          case 'dedicatedCloud':\n            task = OvhApiVrack.DedicatedCloud().v6().create({\n              serviceName: self.serviceName,\n            }, {\n              dedicatedCloud: service.id,\n            }).$promise;\n            break;\n          case 'legacyVrack':\n            task = OvhApiVrack.LegacyVrack().v6().create({\n              serviceName: self.serviceName,\n            }, {\n              legacyVrack: service.id,\n            }).$promise;\n            break;\n          case 'ip':\n            task = OvhApiVrack.Ip().v6().create({\n              serviceName: self.serviceName,\n            }, {\n              block: service.id,\n            }).$promise;\n            break;\n          case 'cloudProject':\n            task = OvhApiVrack.CloudProject().v6().create({\n              serviceName: self.serviceName,\n            }, {\n              project: service.id,\n            }).$promise;\n            break;\n          case 'ipLoadbalancing':\n            task = OvhApiVrack.IpLoadBalancing().v6().create({\n              serviceName: self.serviceName,\n            }, {\n              ipLoadbalancing: service.id,\n            }).$promise;\n            break;\n          default:\n            break;\n        }\n        return task.catch((err) => {\n          CloudMessage.error([$translate.instant('vrack_add_error'), (err.data && err.data.message) || ''].join(' '));\n          return $q.reject(err);\n        });\n      })).then(() => self.refreshData()).finally(() => {\n        self.form.servicesToAdd = [];\n        self.loaders.adding = false;\n      });\n    };\n\n    self.deleteSelectedServices = function () {\n      self.loaders.deleting = true;\n      return $q.all(_.map(self.form.servicesToDelete, (service) => {\n        let task = $q.reject('Unknown service type');\n        switch (service.type) {\n          case 'dedicatedServer':\n            task = OvhApiVrack.DedicatedServer().v6().delete({\n              serviceName: self.serviceName,\n              dedicatedServer: service.id,\n            }).$promise;\n            break;\n          case 'dedicatedServerInterface':\n            task = OvhApiVrack.DedicatedServerInterface().v6().delete({\n              serviceName: self.serviceName,\n              dedicatedServerInterface: service.id,\n            }).$promise;\n            break;\n          case 'dedicatedCloud':\n            task = OvhApiVrack.DedicatedCloud().v6().delete({\n              serviceName: self.serviceName,\n              dedicatedCloud: service.id,\n            }).$promise;\n            break;\n          case 'legacyVrack':\n            task = OvhApiVrack.LegacyVrack().v6().delete({\n              serviceName: self.serviceName,\n              legacyVrack: service.id,\n            }).$promise;\n            break;\n          case 'ip':\n            task = OvhApiVrack.Ip().v6().delete({\n              serviceName: self.serviceName,\n              ip: service.id,\n            }).$promise;\n            break;\n          case 'cloudProject':\n            task = OvhApiVrack.CloudProject().v6().delete({\n              serviceName: self.serviceName,\n              project: service.id,\n            }).$promise;\n            break;\n          case 'ipLoadbalancing':\n            task = OvhApiVrack.IpLoadBalancing().v6().delete({\n              serviceName: self.serviceName,\n              ipLoadbalancing: service.id,\n            }).$promise;\n            break;\n          default:\n            break;\n        }\n        return task.catch((err) => {\n          CloudMessage.error([$translate.instant('vrack_remove_error'), (err.data && err.data.message) || ''].join(' '));\n          return $q.reject(err);\n        });\n      })).then(() => self.refreshData()).finally(() => {\n        self.form.servicesToDelete = [];\n        self.loaders.deleting = false;\n      });\n    };\n\n    self.moveSelectedService = function () {\n      self.modals.move = $uibModal.open({\n        windowTopClass: 'cui-modal',\n        templateUrl: 'app/vrack/move-dialog/vrack-move-dialog.html',\n        controller: 'VrackMoveDialogCtrl as ctrl',\n        resolve: {\n          service() {\n            return _.merge(self.form.serviceToMove, {\n              vrack: self.serviceName,\n            });\n          },\n        },\n      });\n\n      self.modals.move.result.then(() => {\n        self.refreshData();\n      }).finally(() => {\n        self.form.serviceToMove = null;\n      });\n    };\n\n    self.setAccordionState = function (side, kind, offset, value) {\n      self.states.accordions[side][kind][offset] = value;\n    };\n\n    self.getAccordionState = function (side, kind, offset) {\n      if (!_.has(self.states.accordions, [side, kind, offset])) {\n        return true;\n      }\n\n      return self.states.accordions[side][kind][offset];\n    };\n\n    self.toggleAccordion = function (side, kind, offset) {\n      self.states.accordions[side][kind][offset] = !self.states.accordions[side][kind][offset];\n    };\n\n    self.isAdding = function () {\n      return self.form.servicesToAdd.length > 0 && !self.loaders.adding;\n    };\n\n    self.isRemoving = function () {\n      return self.form.servicesToDelete.length > 0 && !self.loaders.deleting;\n    };\n\n    self.isMoving = function () {\n      return self.form.serviceToMove !== null && !self.loaders.moving;\n    };\n\n    self.hasVrackGuideUrl = function () {\n      return false;\n    };\n\n    self.hasServices = function (services) {\n      return _.keys(services).length > 0;\n    };\n\n    function setUserRelatedContent() {\n      OvhApiMe.v6().get().$promise\n        .then((user) => {\n          if (user.ovhSubsidiary === 'FR') {\n            // Roadmap is only available in french\n            self.vRackCloudRoadmapGuide = URLS.guides.vrack.FR;\n          }\n          self.changeOwnerUrl = URLS.changeOwner[user.ovhSubsidiary];\n        });\n    }\n\n    function init() {\n      self.loaders.init = true;\n      self.loadMessage();\n      if (_.isEmpty($stateParams.vrackId)) {\n        OvhApiVrack.v6().query().$promise\n          .then((vracks) => {\n            if (_.isEmpty(vracks)) {\n              $state.go('vrack-add');\n            } else {\n              $state.go('vrack', { vrackId: vracks[0] });\n            }\n          }).catch(() => {\n            $state.go('vrack-add');\n          });\n      } else {\n        // check if the serviceName is valid before loading the services\n        OvhApiVrack.v6().get({\n          serviceName: $stateParams.vrackId,\n        }).$promise.then((resp) => {\n          self.serviceName = $stateParams.vrackId;\n          self.name = resp.name;\n          self.description = resp.description;\n          setUserRelatedContent();\n          self.refreshData();\n        }).catch((err) => {\n          CloudMessage.error([$translate.instant('vrack_error'), (err.data && err.data.message) || ''].join(' '));\n        });\n      }\n    }\n\n    init();\n\n    $scope.$on('$destroy', () => {\n      if (self.poller) {\n        $timeout.cancel(self.poller);\n      }\n    });\n  });\n"]}