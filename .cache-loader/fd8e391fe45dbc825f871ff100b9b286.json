{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/flavor.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/flavor.service.js","mtime":1539717374442},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n(function () {\n  var oldFlavorRegex = /eg|sp|hg|vps-ssd/;\n\n  var CloudFlavorService =\n  /*#__PURE__*/\n  function () {\n    CloudFlavorService.$inject = [\"$filter\", \"CLOUD_FLAVORTYPE_CATEGORY\", \"CLOUD_INSTANCE_CPU_FREQUENCY\", \"CLOUD_INSTANCE_NUMBER_OF_GPUS\"];\n\n    function CloudFlavorService($filter, CLOUD_FLAVORTYPE_CATEGORY, CLOUD_INSTANCE_CPU_FREQUENCY, CLOUD_INSTANCE_NUMBER_OF_GPUS) {\n      _classCallCheck(this, CloudFlavorService);\n\n      this.$filter = $filter;\n      this.CLOUD_FLAVORTYPE_CATEGORY = CLOUD_FLAVORTYPE_CATEGORY;\n      this.CLOUD_INSTANCE_CPU_FREQUENCY = CLOUD_INSTANCE_CPU_FREQUENCY;\n      this.CLOUD_INSTANCE_NUMBER_OF_GPUS = CLOUD_INSTANCE_NUMBER_OF_GPUS;\n    }\n\n    _createClass(CloudFlavorService, [{\n      key: \"getQuotaRam\",\n      value: function getQuotaRam(flavor, quota) {\n        var quotaByRegion = _.find(quota, {\n          region: flavor.region\n        });\n\n        var instanceQuota = _.get(quotaByRegion, 'instance', false);\n\n        if (instanceQuota) {\n          return {\n            max: this.$filter('bytes')(instanceQuota.maxRam, 0, false, 'MB'),\n            used: this.$filter('bytes')(instanceQuota.usedRAM, 0, false, 'MB'),\n            remaining: this.$filter('bytes')(instanceQuota.maxRam - instanceQuota.usedRAM, 0, false, 'MB'),\n            required: this.$filter('bytes')(flavor.ram, 0, false, 'MB')\n          };\n        }\n\n        return null;\n      }\n    }, {\n      key: \"getRequirements\",\n      value: function getRequirements(flavor, image) {\n        return {\n          name: _.get(image, 'name', undefined),\n          currentDisk: this.$filter('bytes')(flavor.disk, 2, false, 'GB'),\n          currentRam: this.$filter('bytes')(flavor.ram, 2, false, 'MB'),\n          requiredDisk: this.$filter('bytes')(image.minDisk, 2, false, 'GB') || undefined,\n          requiredRam: this.$filter('bytes')(image.minRam, 2, false, 'MB') || undefined\n        };\n      }\n    }, {\n      key: \"augmentFlavor\",\n      value: function augmentFlavor(flavor) {\n        if (!flavor) {\n          return null;\n        }\n\n        var augmentedFlavor = _.cloneDeep(flavor);\n\n        augmentedFlavor.frequency = this.CLOUD_INSTANCE_CPU_FREQUENCY[flavor.type];\n\n        if (/vps/.test(flavor.type)) {\n          return Object.assign({\n            vps: true,\n            diskType: 'ssd',\n            flex: false,\n            shortGroupName: flavor.name\n          }, augmentedFlavor);\n        }\n\n        var shortType;\n        var numberType;\n\n        if (flavor.osType === 'windows') {\n          var _flavor$name$split = flavor.name.split('-');\n\n          var _flavor$name$split2 = _slicedToArray(_flavor$name$split, 3);\n\n          shortType = _flavor$name$split2[1];\n          numberType = _flavor$name$split2[2];\n        } else {\n          var _flavor$name$split3 = flavor.name.split('-');\n\n          var _flavor$name$split4 = _slicedToArray(_flavor$name$split3, 2);\n\n          shortType = _flavor$name$split4[0];\n          numberType = _flavor$name$split4[1];\n        }\n\n        if (shortType) {\n          augmentedFlavor.shortType = shortType;\n        }\n\n        if (numberType) {\n          augmentedFlavor.numberType = numberType;\n        }\n\n        if (shortType && numberType) {\n          augmentedFlavor.shortGroupName = \"\".concat(shortType, \"-\").concat(numberType);\n        }\n\n        augmentedFlavor.flex = /flex$/.test(flavor.name);\n        augmentedFlavor.diskType = [/ssd/, /nvme/].some(function (regex) {\n          return regex.test(flavor.type);\n        }) ? 'ssd' : 'ceph';\n\n        var flavorContainsGPUs = _(['g1', 'g2', 'g3', 't1']).includes(augmentedFlavor.shortType);\n\n        if (flavorContainsGPUs) {\n          augmentedFlavor.imageType = flavor.osType === 'windows' ? ['uefi'] : augmentedFlavor.imageType;\n          augmentedFlavor.gpuCardCount = _(this.CLOUD_INSTANCE_NUMBER_OF_GPUS).get(numberType, this.CLOUD_INSTANCE_NUMBER_OF_GPUS.default);\n        }\n\n        augmentedFlavor.isOldFlavor = CloudFlavorService.isOldFlavor(flavor.name);\n        return augmentedFlavor;\n      }\n    }, {\n      key: \"getCategory\",\n      value: function getCategory(flavorType) {\n        return _(this.CLOUD_FLAVORTYPE_CATEGORY).find(function (currentCategory) {\n          return _(currentCategory.types).includes(flavorType);\n        });\n      }\n    }], [{\n      key: \"isOldFlavor\",\n      value: function isOldFlavor(flavorName) {\n        return oldFlavorRegex.test(flavorName);\n      }\n    }, {\n      key: \"getFlavorTypes\",\n      value: function getFlavorTypes(flavors) {\n        return _.uniq(_.map(flavors, 'type'));\n      }\n    }, {\n      key: \"addPriceInfos\",\n      value: function addPriceInfos(flavor, prices) {\n        var price = {\n          price: {\n            value: 0\n          },\n          monthlyPrice: {\n            value: 0\n          }\n        };\n\n        var planHourly = prices[_.get(flavor, 'planCodes.hourly')];\n\n        if (planHourly) {\n          _.set(price, 'price', planHourly.price); // Set 3 digits for hourly price\n\n\n          _.set(price, 'price.text', _.get(price, 'price.text', '').replace(/\\d+(?:[.,]\\d+)?/, \"\".concat(price.price.value.toFixed(3))));\n        }\n\n        var planMonthly = prices[_.get(flavor, 'planCodes.monthly')];\n\n        if (planMonthly) {\n          _.set(price, 'monthlyPrice', planMonthly.price);\n        }\n\n        _.set(flavor, 'price', price);\n      }\n    }, {\n      key: \"addOverQuotaInfos\",\n      value: function addOverQuotaInfos(flavor, quota) {\n        var minDisk = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var minRam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n        var quotaByRegion = _.find(quota, {\n          region: flavor.region\n        });\n\n        var instanceQuota = _.get(quotaByRegion, 'instance', false);\n\n        if (instanceQuota) {\n          // set over quota reason\n          if (instanceQuota.maxInstances !== -1 && instanceQuota.usedInstances >= instanceQuota.maxInstances) {\n            _.set(flavor, 'disabled', 'QUOTA_INSTANCE');\n          } else if (flavor.ram && instanceQuota.maxRam !== -1 && flavor.ram > instanceQuota.maxRam - instanceQuota.usedRAM) {\n            _.set(flavor, 'disabled', 'QUOTA_RAM');\n          } else if (flavor.vcpus && instanceQuota.maxCores !== -1 && flavor.vcpus > instanceQuota.maxCores - instanceQuota.usedCores) {\n            _.set(flavor, 'disabled', 'QUOTA_VCPUS');\n          } // set max instances (-1 : unlimited)\n\n\n          if (instanceQuota.maxInstances === -1) {\n            _.set(flavor, 'maxInstance', -1);\n          } else {\n            _.set(flavor, 'maxInstance', instanceQuota.maxInstances - instanceQuota.usedInstances);\n          }\n\n          if (instanceQuota.maxRam === -1) {\n            _.set(flavor, 'maxInstance', Math.max(flavor.maxInstance, -1));\n          } else {\n            _.set(flavor, 'maxInstance', Math.min(flavor.maxInstance > -1 ? flavor.maxInstance : 1000, Math.floor((instanceQuota.maxRam - instanceQuota.usedRAM) / flavor.ram)));\n          }\n\n          if (instanceQuota.maxCores === -1) {\n            _.set(flavor, 'maxInstance', Math.max(flavor.maxInstance, -1));\n          } else {\n            _.set(flavor, 'maxInstance', Math.min(flavor.maxInstance > -1 ? flavor.maxInstance : 1000, Math.floor((instanceQuota.maxCores - instanceQuota.usedCores) / flavor.vcpus)));\n          }\n        }\n\n        if (minDisk > flavor.disk && !flavor.disabled) {\n          _.set(flavor, 'disabled', 'QUOTA_MINDISK');\n        }\n\n        if (minRam > flavor.ram && !flavor.disabled) {\n          _.set(flavor, 'disabled', 'QUOTA_MINRAM');\n        }\n      }\n    }, {\n      key: \"getQuotaCore\",\n      value: function getQuotaCore(flavor, quota) {\n        var quotaByRegion = _.find(quota, {\n          region: flavor.region\n        });\n\n        var instanceQuota = _.get(quotaByRegion, 'instance', false);\n\n        if (instanceQuota) {\n          return {\n            max: instanceQuota.maxCores,\n            used: instanceQuota.usedCores,\n            remaining: instanceQuota.maxCores - instanceQuota.usedCores,\n            required: flavor.vcpus\n          };\n        }\n\n        return null;\n      }\n    }]);\n\n    return CloudFlavorService;\n  }();\n\n  angular.module('managerApp').service('CloudFlavorService', CloudFlavorService);\n})();",null]}