{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/common/cloud-message.service.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/common/cloud-message.service.js","mtime":1539717142058},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CloudMessage =\n/*#__PURE__*/\nfunction () {\n  CloudMessage.$inject = [\"$transitions\", \"$state\"];\n\n  function CloudMessage($transitions, $state) {\n    var _this = this;\n\n    _classCallCheck(this, CloudMessage);\n\n    this.$state = $state;\n    this.messages = {};\n    this.subscribers = {};\n    $transitions.onSuccess({}, function () {\n      _this.flushChildMessage();\n    });\n  }\n\n  _createClass(CloudMessage, [{\n    key: \"success\",\n    value: function success(message, containerName) {\n      this.logMessage(_.isPlainObject(message) ? message : {\n        text: message\n      }, 'success', containerName);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message, containerName) {\n      this.logMessage(_.isPlainObject(message) ? message : {\n        text: message\n      }, 'error', containerName);\n    }\n  }, {\n    key: \"warning\",\n    value: function warning(message, containerName) {\n      this.logMessage(_.isPlainObject(message) ? message : {\n        text: message\n      }, 'warning', containerName);\n    }\n  }, {\n    key: \"info\",\n    value: function info(message, containerName) {\n      this.logMessage(_.isPlainObject(message) ? message : {\n        text: message\n      }, 'info', containerName);\n    }\n    /*\n     * Handle the message type (error, warning, ...etc) and push the message to the messageHandler\n     */\n\n  }, {\n    key: \"logMessage\",\n    value: function logMessage(messageHash, type, containerName) {\n      if (!messageHash.text && !messageHash.textHtml) {\n        return;\n      }\n\n      var messageHandler = this.getMessageHandler(containerName);\n\n      if (messageHandler) {\n        // Message age defines how many flush the message went through.\n        messageHandler.messages.push(_.extend({\n          type: type,\n          origin: containerName || this.$state.current.name,\n          timestamp: moment().valueOf()\n        }, messageHash));\n        messageHandler.onMessage();\n      } else {\n        console.log(\"Unhandled message \".concat(messageHash.text));\n      }\n    }\n    /*\n     * Handle message to dispatch.\n     * @params containerName : custom name for the container\n     * if no params is passed, it will take the current state name as containerName\n     */\n\n    /* eslint-disable no-param-reassign */\n\n  }, {\n    key: \"getMessageHandler\",\n    value: function getMessageHandler(containerName) {\n      containerName = \"\".concat(containerName || this.$state.current.name, \".\");\n      var messageHandler = null;\n\n      do {\n        containerName = containerName.substring(0, _.lastIndexOf(containerName, '.'));\n        messageHandler = this.subscribers[containerName];\n      } while (!messageHandler && _.includes(containerName, '.'));\n\n      return messageHandler;\n    }\n    /* eslint-enable no-param-reassign */\n\n    /*\n     * Retrieve messages\n     */\n\n  }, {\n    key: \"getMessages\",\n    value: function getMessages(containerName) {\n      return this.subscribers[containerName].messages;\n    }\n    /*\n     * Flush currents messages\n     */\n\n  }, {\n    key: \"flushMessages\",\n    value: function flushMessages(containerName) {\n      var messageHandler = this.getMessageHandler(containerName);\n\n      if (messageHandler) {\n        messageHandler.messages = [];\n        messageHandler.onMessage();\n      }\n    }\n  }, {\n    key: \"flushChildMessage\",\n    value: function flushChildMessage(containerName) {\n      var messageHandler = this.getMessageHandler(containerName);\n\n      if (messageHandler) {\n        var now = moment().valueOf();\n        messageHandler.messages = _.filter(messageHandler.messages, function (message) {\n          return message.origin === messageHandler.containerName || !message.forceFlush && now - 500 < message.timestamp;\n        });\n\n        _.forEach(messageHandler.messages, function (message) {\n          if (message.origin !== messageHandler.containerName) {\n            _.set(message, 'forceFlush', true);\n          }\n        });\n\n        messageHandler.onMessage();\n      }\n    }\n    /*\n     * unsubscribe to the message receiver.\n     */\n\n  }, {\n    key: \"unSubscribe\",\n    value: function unSubscribe(containerName) {\n      var subscriber = this.subscribers[containerName];\n\n      if (subscriber) {\n        this.subscribers[containerName].messages = [];\n        this.subscribers[containerName].onMessage();\n      }\n\n      this.subscribers = _.omit(this.subscribers, containerName);\n    }\n    /*\n     * subscibe to the message receiver.\n     * @params containerName : container name or the state name to subscribe\n     * @params params actions to do\n     * ex params : { onMessage: () => this.getMessage() }\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(containerName, params) {\n      var _this2 = this;\n\n      this.subscribers[containerName] = _.extend({\n        containerName: containerName,\n        messages: [],\n        onMessage: _.noop()\n      }, params);\n      return {\n        getMessages: function getMessages() {\n          return _this2.getMessages(containerName);\n        }\n      };\n    }\n  }]);\n\n  return CloudMessage;\n}();\n\nangular.module('managerApp').service('CloudMessage', CloudMessage);",null]}