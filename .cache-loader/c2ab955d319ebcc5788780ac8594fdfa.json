{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/vrack/vrack.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/vrack/vrack.controller.js","mtime":1539717142312},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["angular.module('managerApp').controller('VrackCtrl', [\"$scope\", \"$q\", \"$stateParams\", \"$state\", \"$timeout\", \"$translate\", \"$uibModal\", \"CloudMessage\", \"SidebarMenu\", \"OvhApiVrack\", \"OvhApiCloudProject\", \"OvhApiMe\", \"URLS\", \"VrackService\", function VrackCtrl($scope, $q, $stateParams, $state, $timeout, $translate, $uibModal, CloudMessage, SidebarMenu, OvhApiVrack, OvhApiCloudProject, OvhApiMe, URLS, VrackService) {\n  var self = this;\n  var pollingInterval = 5000;\n  self.poller = null;\n  self.serviceName = null;\n  self.name = null;\n  self.description = null;\n  self.nameEditing = false;\n  self.descriptionEditing = false;\n  self.nameOptions = {\n    pattern: /^([a-zA-Z])\\S*$/,\n    maxLength: 100\n  };\n  self.descriptionOptions = {\n    maxLength: 255\n  };\n  self.changeOwnerUrl = null;\n  self.vRackCloudRoadmapGuide = null;\n  self.vrackService = VrackService;\n  self.modals = {\n    move: null\n  };\n  self.messages = [];\n  self.loaders = {\n    init: false,\n    adding: false,\n    deleting: false,\n    moving: false\n  };\n  self.data = {\n    cloudProjects: [],\n    allowedServices: {},\n    vrackServices: {},\n    pendingTasks: []\n  };\n  self.form = {\n    servicesToAdd: [],\n    servicesToDelete: [],\n    serviceToMove: null\n  };\n  self.states = {\n    accordions: {\n      available: {\n        types: [],\n        groups: [],\n        dedicatedCloudNetworks: []\n      },\n      mapped: {\n        types: [],\n        groups: [],\n        dedicatedCloudNetworks: [],\n        dedicatedCloudDatacenters: []\n      }\n    }\n  };\n\n  self.refreshMessage = function () {\n    self.messages = self.messageHandler.getMessages();\n  };\n\n  self.loadMessage = function () {\n    CloudMessage.unSubscribe('vrack');\n    self.messageHandler = CloudMessage.subscribe('vrack', {\n      onMessage: function onMessage() {\n        return self.refreshMessage();\n      }\n    });\n  };\n\n  self.groupedServiceKeys = {\n    dedicatedCloudDatacenter: 'dedicatedCloud.niceName',\n    dedicatedServerInterface: 'dedicatedServer.niceName'\n  };\n\n  self.getDisplayName = function (serviceType) {\n    return $translate.instant(\"vrack_service_type_\".concat(serviceType.toLowerCase()));\n  };\n\n  function getDedicatedServerNiceName(service) {\n    var formattedService = {};\n    angular.copy(service, formattedService);\n    formattedService.id = service.name; // by default the reverse seem to be equal to the name,\n    // so do not display redondant information.\n\n    if (service.reverse && service.reverse !== service.name) {\n      formattedService.niceName = \"\".concat(service.name, \" (\").concat(service.reverse, \")\");\n    } else {\n      formattedService.niceName = service.name;\n    }\n\n    formattedService.trueServiceType = 'dedicatedServer';\n    return formattedService;\n  }\n\n  function getDedicatedServerInterfaceNiceName(service) {\n    var formattedService = getDedicatedServerNiceName(service.dedicatedServer);\n    formattedService.id = service.dedicatedServerInterface;\n    formattedService.niceName = \"\".concat(formattedService.niceName, \" - \").concat(service.name);\n    formattedService.trueServiceType = 'dedicatedServerInterface';\n    return formattedService;\n  }\n\n  function getDedicatedCloudNiceName(service) {\n    var formattedService = {};\n    angular.copy(service, formattedService);\n    formattedService.id = service.serviceName;\n\n    if (service.description) {\n      formattedService.niceName = \"\".concat(service.serviceName, \" (\").concat(service.description, \")\");\n    } else {\n      formattedService.niceName = service.serviceName;\n    }\n\n    formattedService.trueServiceType = 'dedicatedCloud';\n    return formattedService;\n  }\n\n  function getCloudProjectNiceName(service) {\n    var formattedService = {};\n    angular.copy(service, formattedService);\n    formattedService.id = service.project_id;\n\n    if (service.description) {\n      formattedService.niceName = service.description;\n    } else {\n      formattedService.niceName = service.project_id;\n    }\n\n    formattedService.trueServiceType = 'cloudProject';\n    return formattedService;\n  }\n\n  function getIpLoadbalancingNiceName(service) {\n    var formattedService = {};\n    angular.copy(service, formattedService);\n    formattedService.id = service.serviceName;\n\n    if (service.displayName) {\n      formattedService.niceName = service.displayName;\n    } else {\n      formattedService.niceName = service.serviceName;\n    }\n\n    formattedService.trueServiceType = 'ipLoadbalancing';\n    return formattedService;\n  }\n\n  function fillServiceData(serviceType, service) {\n    var formattedService = null;\n\n    switch (serviceType) {\n      case 'dedicatedServer':\n        formattedService = getDedicatedServerNiceName(service);\n        break;\n\n      case 'dedicatedServerInterface':\n        formattedService = getDedicatedServerInterfaceNiceName(service);\n        break;\n\n      case 'dedicatedCloud':\n        formattedService = getDedicatedCloudNiceName(service);\n        break;\n\n      case 'dedicatedCloudDatacenter':\n        formattedService = _.cloneDeep(service);\n        formattedService.id = service.datacenter;\n        formattedService.niceName = _.last(service.datacenter.split('_'));\n\n        if (_.isObject(service.dedicatedCloud)) {\n          formattedService.dedicatedCloud.niceName = \"\".concat(service.dedicatedCloud.serviceName, \" (\").concat(service.dedicatedCloud.description, \")\");\n        } else {\n          formattedService.dedicatedCloud = {\n            niceName: service.dedicatedCloud\n          };\n        }\n\n        formattedService.trueServiceType = 'dedicatedCloudDatacenter';\n        break;\n\n      case 'legacyVrack':\n        formattedService = {\n          id: service,\n          niceName: service,\n          trueServiceType: 'legacyVrack'\n        };\n        break;\n\n      case 'ip':\n        formattedService = {\n          id: service,\n          niceName: service,\n          trueServiceType: 'ip'\n        };\n        break;\n\n      case 'cloudProject':\n        formattedService = getCloudProjectNiceName(service);\n        break;\n\n      case 'ipLoadbalancing':\n        formattedService = getIpLoadbalancingNiceName(service);\n        break;\n\n      default:\n        formattedService = _.cloneDeep(service);\n        break;\n    }\n\n    return formattedService;\n  }\n\n  self.getAllowedServices = function () {\n    return OvhApiVrack.Aapi().allowedServices({\n      serviceName: self.serviceName\n    }).$promise.then(function (allServicesParam) {\n      var allServices = allServicesParam;\n      allServices = _.mapValues(allServices, function (services, serviceType) {\n        if (_.isArray(services)) {\n          return _.map(services, function (service) {\n            return fillServiceData(serviceType, service);\n          });\n        }\n\n        return services;\n      }); // We need to append dedicatedServerInterfaces list to dedicatedServers list.\n\n      if (_.has(allServices, 'dedicatedServerInterface') && allServices.dedicatedServerInterface.length > 0) {\n        // If dedicatedServers list doesn't exist, we create it first.\n        if (!_.has(allServices, 'dedicatedServer')) {\n          allServices.dedicatedServer = [];\n        }\n\n        angular.forEach(allServices.dedicatedServerInterface, function (serverInterface) {\n          allServices.dedicatedServer.push(serverInterface);\n        });\n        allServices.dedicatedServerInterface = [];\n      }\n\n      return allServices;\n    });\n  };\n\n  self.getVrackServices = function () {\n    return OvhApiVrack.Aapi().services({\n      serviceName: self.serviceName\n    }).$promise.then(function (allServicesParam) {\n      var allServices = allServicesParam;\n      allServices = _.mapValues(allServices, function (servicesParams, serviceType) {\n        var services = servicesParams;\n\n        if (_.isArray(services)) {\n          services = _.map(services, function (service) {\n            return fillServiceData(serviceType, service);\n          });\n        }\n\n        return services;\n      });\n\n      if (_.has(allServices, 'dedicatedCloudDatacenter')) {\n        allServices.dedicatedCloudDatacenter = _.groupBy(allServices.dedicatedCloudDatacenter, self.groupedServiceKeys.dedicatedCloudDatacenter);\n      } // We need to append dedicatedServerInterfaces list to dedicatedServers list.\n\n\n      if (_.has(allServices, 'dedicatedServerInterface') && allServices.dedicatedServerInterface.length > 0) {\n        // If dedicatedServers list doesn't exist, we create it first.\n        if (!_.has(allServices, 'dedicatedServer')) {\n          allServices.dedicatedServer = [];\n        }\n\n        angular.forEach(allServices.dedicatedServerInterface, function (serverInterface) {\n          allServices.dedicatedServer.push(serverInterface);\n        });\n        allServices.dedicatedServerInterface = [];\n      }\n\n      return allServices;\n    });\n  };\n\n  self.getPendingTasks = function () {\n    return OvhApiVrack.v6().tasks({\n      serviceName: self.serviceName\n    }).$promise.then(function (taskIds) {\n      return $q.all(_.map(taskIds, function (id) {\n        return OvhApiVrack.v6().task({\n          serviceName: self.serviceName,\n          taskId: id\n        }).$promise.then(function (task) {\n          return task;\n        }).catch(function (err) {\n          return err.status === 404 ? $q.when(null) : $q.reject(err);\n        });\n      })).then(function (tasks) {\n        return _.without(tasks, null);\n      });\n    });\n  };\n\n  self.resetCache = function () {\n    OvhApiVrack.v6().resetCache();\n    OvhApiVrack.CloudProject().v6().resetQueryCache();\n    OvhApiVrack.IpLoadBalancing().v6().resetQueryCache();\n    OvhApiVrack.DedicatedCloud().v6().resetQueryCache();\n    OvhApiVrack.DedicatedServer().v6().resetQueryCache();\n    OvhApiVrack.DedicatedServerInterface().v6().resetQueryCache();\n    OvhApiVrack.Ip().v6().resetQueryCache();\n    OvhApiVrack.LegacyVrack().v6().resetQueryCache();\n    OvhApiVrack.Aapi().resetAllCache();\n  };\n\n  self.moveDisplayedService = function (serviceId, allServicesSource, allServicesDestination) {\n    var serviceToMove = null;\n    var typeToMove = null;\n    var isGroupedServicesType = false;\n\n    _.forEach(allServicesSource, function (services, type) {\n      var servicesToSearch = !_.isArray(allServicesSource[type]) ? _.flatten(_.values(allServicesSource[type])) : allServicesSource[type];\n      serviceToMove = _.remove(servicesToSearch, function (service) {\n        if (service.id === serviceId) {\n          typeToMove = type;\n          isGroupedServicesType = !_.isArray(allServicesSource[type]);\n          return true;\n        }\n\n        return null;\n      });\n\n      if (!_.isEmpty(serviceToMove)) {\n        if (isGroupedServicesType) {\n          allServicesSource[typeToMove] = _.groupBy(servicesToSearch, self.groupedServiceKeys[typeToMove]); // eslint-disable-line\n        } else {\n          allServicesSource[typeToMove] = servicesToSearch; // eslint-disable-line\n        }\n\n        return false;\n      }\n\n      return null;\n    });\n\n    if (serviceToMove && typeToMove) {\n      if (isGroupedServicesType) {\n        var services = _.flatten(_.values(allServicesDestination[typeToMove]));\n\n        services.push(serviceToMove[0]);\n        allServicesDestination[typeToMove] = _.groupBy(services, self.groupedServiceKeys[typeToMove]); // eslint-disable-line\n      } else {\n        allServicesDestination[typeToMove].push(serviceToMove[0]);\n      }\n    }\n  };\n\n  self.refreshData = function () {\n    var poll = true;\n    return self.getPendingTasks().then(function (tasks) {\n      /**\n           * First, we check if there is any new pending tasks ...\n           */\n      var currentTasks = _.pluck(tasks, 'id');\n\n      var previousTasks = _.pluck(self.data.pendingTasks, 'id');\n\n      if (_.difference(currentTasks, previousTasks).length || _.difference(previousTasks, currentTasks).length) {\n        self.resetCache(); // a task changed, vrack state might have changed too\n      } else if (tasks.length === 0) {\n        poll = false; // no new tasks & no tasks, no need to poll\n      }\n      /**\n           * Secondly, we fetch vrack data ...\n           */\n\n\n      return $q.all({\n        allowedServices: self.getAllowedServices(),\n        vrackServices: self.getVrackServices()\n      }).then(function (result) {\n        self.data.pendingTasks = tasks;\n        self.data.allowedServices = result.allowedServices;\n        self.data.vrackServices = result.vrackServices;\n        /**\n               * Finally, check if some tasks are adding or removing services in vrack\n               * and move the service in his \"future\" column\n               */\n\n        angular.forEach(self.data.pendingTasks, function (task) {\n          if (task && task.targetDomain) {\n            var id = task.targetDomain;\n            var fn = task.function;\n\n            if (_.startsWith(fn, 'add')) {\n              self.moveDisplayedService(id, self.data.allowedServices, self.data.vrackServices);\n            } else if (_.startsWith(fn, 'remove')) {\n              self.moveDisplayedService(id, self.data.vrackServices, self.data.allowedServices);\n            }\n\n            self.form.servicesToAdd = _.reject(self.form.servicesToAdd, {\n              id: id\n            });\n            self.form.servicesToDelete = _.reject(self.form.servicesToDelete, {\n              id: id\n            });\n          }\n        });\n      });\n    }).finally(function () {\n      // if there are some pending tasks, poll\n      if (poll && !self.poller) {\n        self.poller = $timeout(function () {\n          self.poller = null;\n          self.refreshData();\n        }, pollingInterval);\n      }\n\n      self.loaders.init = false;\n    });\n  };\n\n  self.isSelected = function (serviceType, serviceId) {\n    return angular.isDefined(_.find(self.form.servicesToAdd, {\n      type: serviceType,\n      id: serviceId\n    })) || angular.isDefined(_.find(self.form.servicesToDelete, {\n      type: serviceType,\n      id: serviceId\n    })) || _.isEqual(self.form.serviceToMove, {\n      type: serviceType,\n      id: serviceId\n    });\n  };\n\n  self.isPending = function (serviceId) {\n    var ids = _.uniq(_.pluck(self.data.pendingTasks, 'targetDomain'));\n\n    return ids.indexOf(serviceId) >= 0;\n  };\n\n  self.toggleAddService = function (serviceType, serviceId) {\n    if (!self.isPending(serviceId) && !self.loaders.adding && !self.loaders.deleting) {\n      var toAdd = {\n        type: serviceType,\n        id: serviceId\n      };\n\n      if (_.find(self.form.servicesToAdd, toAdd)) {\n        self.form.servicesToAdd = _.reject(self.form.servicesToAdd, toAdd);\n      } else {\n        self.form.servicesToAdd.push(toAdd);\n      }\n\n      self.form.serviceToMove = null;\n      self.form.servicesToDelete = [];\n    }\n  };\n\n  self.toggleDeleteService = function (serviceType, serviceId) {\n    if (!self.isPending(serviceId) && !self.loaders.adding && !self.loaders.deleting) {\n      var toDelete = {\n        type: serviceType,\n        id: serviceId\n      };\n\n      if (_.find(self.form.servicesToDelete, toDelete)) {\n        self.form.servicesToDelete = _.reject(self.form.servicesToDelete, toDelete);\n      } else {\n        self.form.servicesToDelete.push(toDelete);\n      }\n\n      self.form.serviceToMove = null;\n      self.form.servicesToAdd = [];\n    }\n  };\n\n  self.toggleMoveService = function (serviceType, serviceId) {\n    if (self.isPending(serviceId) || self.loaders.moving) {\n      return;\n    }\n\n    var toMove = {\n      type: serviceType,\n      id: serviceId\n    };\n\n    if (self.form.serviceToMove === null) {\n      self.form.servicesToAdd = [];\n      self.form.servicesToDelete = [];\n      self.form.serviceToMove = toMove;\n    } else {\n      self.form.serviceToMove = null;\n    }\n  };\n\n  self.editName = function () {\n    self.nameEditing = true;\n    self.nameBackup = self.name;\n  };\n\n  self.cancelEditName = function () {\n    self.nameEditing = false;\n    self.name = self.nameBackup;\n  };\n\n  self.saveName = function () {\n    self.nameEditing = false;\n    OvhApiVrack.v6().edit({\n      serviceName: self.serviceName\n    }, {\n      name: self.name\n    }).$promise.catch(function (err) {\n      self.name = self.nameBackup;\n      CloudMessage.error([$translate.instant('vrack_error'), err.data && err.data.message || err.message || ''].join(' '));\n    }).finally(function () {\n      var menuItem = SidebarMenu.getItemById(self.serviceName);\n\n      if (menuItem) {\n        menuItem.title = self.name || self.serviceName;\n      }\n\n      self.nameBackup = null;\n    });\n  };\n\n  self.editDescription = function () {\n    self.descriptionEditing = true;\n    self.descriptionBackup = self.description;\n  };\n\n  self.cancelEditDescription = function () {\n    self.descriptionEditing = false;\n    self.description = self.descriptionBackup;\n  };\n\n  self.saveDescription = function () {\n    self.descriptionEditing = false;\n    OvhApiVrack.v6().edit({\n      serviceName: self.serviceName\n    }, {\n      description: self.description\n    }).$promise.catch(function (err) {\n      self.description = self.descriptionBackup;\n      CloudMessage.error([$translate.instant('vrack_error'), err.data && err.data.message || err.message || ''].join(' '));\n    }).finally(function () {\n      self.descriptionBackup = null;\n    });\n  };\n\n  self.addSelectedServices = function () {\n    self.loaders.adding = true;\n    return $q.all(_.map(self.form.servicesToAdd, function (service) {\n      var task = $q.reject('Unknown service type');\n\n      switch (service.type) {\n        case 'dedicatedServer':\n          task = OvhApiVrack.DedicatedServer().v6().create({\n            serviceName: self.serviceName\n          }, {\n            dedicatedServer: service.id\n          }).$promise;\n          break;\n\n        case 'dedicatedServerInterface':\n          task = OvhApiVrack.DedicatedServerInterface().v6().post({\n            serviceName: self.serviceName\n          }, {\n            dedicatedServerInterface: service.id\n          }).$promise;\n          break;\n\n        case 'dedicatedCloud':\n          task = OvhApiVrack.DedicatedCloud().v6().create({\n            serviceName: self.serviceName\n          }, {\n            dedicatedCloud: service.id\n          }).$promise;\n          break;\n\n        case 'legacyVrack':\n          task = OvhApiVrack.LegacyVrack().v6().create({\n            serviceName: self.serviceName\n          }, {\n            legacyVrack: service.id\n          }).$promise;\n          break;\n\n        case 'ip':\n          task = OvhApiVrack.Ip().v6().create({\n            serviceName: self.serviceName\n          }, {\n            block: service.id\n          }).$promise;\n          break;\n\n        case 'cloudProject':\n          task = OvhApiVrack.CloudProject().v6().create({\n            serviceName: self.serviceName\n          }, {\n            project: service.id\n          }).$promise;\n          break;\n\n        case 'ipLoadbalancing':\n          task = OvhApiVrack.IpLoadBalancing().v6().create({\n            serviceName: self.serviceName\n          }, {\n            ipLoadbalancing: service.id\n          }).$promise;\n          break;\n\n        default:\n          break;\n      }\n\n      return task.catch(function (err) {\n        CloudMessage.error([$translate.instant('vrack_add_error'), err.data && err.data.message || ''].join(' '));\n        return $q.reject(err);\n      });\n    })).then(function () {\n      return self.refreshData();\n    }).finally(function () {\n      self.form.servicesToAdd = [];\n      self.loaders.adding = false;\n    });\n  };\n\n  self.deleteSelectedServices = function () {\n    self.loaders.deleting = true;\n    return $q.all(_.map(self.form.servicesToDelete, function (service) {\n      var task = $q.reject('Unknown service type');\n\n      switch (service.type) {\n        case 'dedicatedServer':\n          task = OvhApiVrack.DedicatedServer().v6().delete({\n            serviceName: self.serviceName,\n            dedicatedServer: service.id\n          }).$promise;\n          break;\n\n        case 'dedicatedServerInterface':\n          task = OvhApiVrack.DedicatedServerInterface().v6().delete({\n            serviceName: self.serviceName,\n            dedicatedServerInterface: service.id\n          }).$promise;\n          break;\n\n        case 'dedicatedCloud':\n          task = OvhApiVrack.DedicatedCloud().v6().delete({\n            serviceName: self.serviceName,\n            dedicatedCloud: service.id\n          }).$promise;\n          break;\n\n        case 'legacyVrack':\n          task = OvhApiVrack.LegacyVrack().v6().delete({\n            serviceName: self.serviceName,\n            legacyVrack: service.id\n          }).$promise;\n          break;\n\n        case 'ip':\n          task = OvhApiVrack.Ip().v6().delete({\n            serviceName: self.serviceName,\n            ip: service.id\n          }).$promise;\n          break;\n\n        case 'cloudProject':\n          task = OvhApiVrack.CloudProject().v6().delete({\n            serviceName: self.serviceName,\n            project: service.id\n          }).$promise;\n          break;\n\n        case 'ipLoadbalancing':\n          task = OvhApiVrack.IpLoadBalancing().v6().delete({\n            serviceName: self.serviceName,\n            ipLoadbalancing: service.id\n          }).$promise;\n          break;\n\n        default:\n          break;\n      }\n\n      return task.catch(function (err) {\n        CloudMessage.error([$translate.instant('vrack_remove_error'), err.data && err.data.message || ''].join(' '));\n        return $q.reject(err);\n      });\n    })).then(function () {\n      return self.refreshData();\n    }).finally(function () {\n      self.form.servicesToDelete = [];\n      self.loaders.deleting = false;\n    });\n  };\n\n  self.moveSelectedService = function () {\n    self.modals.move = $uibModal.open({\n      windowTopClass: 'cui-modal',\n      templateUrl: 'app/vrack/move-dialog/vrack-move-dialog.html',\n      controller: 'VrackMoveDialogCtrl as ctrl',\n      resolve: {\n        service: function service() {\n          return _.merge(self.form.serviceToMove, {\n            vrack: self.serviceName\n          });\n        }\n      }\n    });\n    self.modals.move.result.then(function () {\n      self.refreshData();\n    }).finally(function () {\n      self.form.serviceToMove = null;\n    });\n  };\n\n  self.setAccordionState = function (side, kind, offset, value) {\n    self.states.accordions[side][kind][offset] = value;\n  };\n\n  self.getAccordionState = function (side, kind, offset) {\n    if (!_.has(self.states.accordions, [side, kind, offset])) {\n      return true;\n    }\n\n    return self.states.accordions[side][kind][offset];\n  };\n\n  self.toggleAccordion = function (side, kind, offset) {\n    self.states.accordions[side][kind][offset] = !self.states.accordions[side][kind][offset];\n  };\n\n  self.isAdding = function () {\n    return self.form.servicesToAdd.length > 0 && !self.loaders.adding;\n  };\n\n  self.isRemoving = function () {\n    return self.form.servicesToDelete.length > 0 && !self.loaders.deleting;\n  };\n\n  self.isMoving = function () {\n    return self.form.serviceToMove !== null && !self.loaders.moving;\n  };\n\n  self.hasVrackGuideUrl = function () {\n    return false;\n  };\n\n  self.hasServices = function (services) {\n    return _.keys(services).length > 0;\n  };\n\n  function setUserRelatedContent() {\n    OvhApiMe.v6().get().$promise.then(function (user) {\n      if (user.ovhSubsidiary === 'FR') {\n        // Roadmap is only available in french\n        self.vRackCloudRoadmapGuide = URLS.guides.vrack.FR;\n      }\n\n      self.changeOwnerUrl = URLS.changeOwner[user.ovhSubsidiary];\n    });\n  }\n\n  function init() {\n    self.loaders.init = true;\n    self.loadMessage();\n\n    if (_.isEmpty($stateParams.vrackId)) {\n      OvhApiVrack.v6().query().$promise.then(function (vracks) {\n        if (_.isEmpty(vracks)) {\n          $state.go('vrack-add');\n        } else {\n          $state.go('vrack', {\n            vrackId: vracks[0]\n          });\n        }\n      }).catch(function () {\n        $state.go('vrack-add');\n      });\n    } else {\n      // check if the serviceName is valid before loading the services\n      OvhApiVrack.v6().get({\n        serviceName: $stateParams.vrackId\n      }).$promise.then(function (resp) {\n        self.serviceName = $stateParams.vrackId;\n        self.name = resp.name;\n        self.description = resp.description;\n        setUserRelatedContent();\n        self.refreshData();\n      }).catch(function (err) {\n        CloudMessage.error([$translate.instant('vrack_error'), err.data && err.data.message || ''].join(' '));\n      });\n    }\n  }\n\n  init();\n  $scope.$on('$destroy', function () {\n    if (self.poller) {\n      $timeout.cancel(self.poller);\n    }\n  });\n}]);",null]}