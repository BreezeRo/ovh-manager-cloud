{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js??ref--10-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/dbaas/logs/detail/streams/archives/streams-archives.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/dbaas/logs/detail/streams/archives/streams-archives.controller.js","mtime":1539717142148},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/.babelrc","mtime":1539717141926},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar LogsStreamsArchivesCtrl =\n/*#__PURE__*/\nfunction () {\n  LogsStreamsArchivesCtrl.$inject = [\"$interval\", \"$state\", \"$stateParams\", \"$translate\", \"CloudMessage\", \"ControllerHelper\", \"LogsStreamsService\", \"LogsConstants\", \"LogsStreamsArchivesService\"];\n\n  function LogsStreamsArchivesCtrl($interval, $state, $stateParams, $translate, CloudMessage, ControllerHelper, LogsStreamsService, LogsConstants, LogsStreamsArchivesService) {\n    _classCallCheck(this, LogsStreamsArchivesCtrl);\n\n    this.$interval = $interval;\n    this.$state = $state;\n    this.$stateParams = $stateParams;\n    this.$translate = $translate;\n    this.CloudMessage = CloudMessage;\n    this.ControllerHelper = ControllerHelper;\n    this.LogsStreamsService = LogsStreamsService;\n    this.LogsConstants = LogsConstants;\n    this.LogsStreamsArchivesService = LogsStreamsArchivesService;\n    this.serviceName = this.$stateParams.serviceName;\n    this.streamId = this.$stateParams.streamId;\n    this.initLoaders();\n  }\n\n  _createClass(LogsStreamsArchivesCtrl, [{\n    key: \"$onInit\",\n    value: function $onInit() {\n      this.archiveIds.load();\n      this.stream.load();\n      this.notifications = [];\n    }\n  }, {\n    key: \"$destroy\",\n    value: function $destroy() {\n      this.stopRetrievalDelayUpdate();\n    }\n    /**\n     * Gets the notificaiton index for an archive if available\n     *\n     * @param {any} archive\n     * @returns the notification index. Returns -1 if not found\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"getNotificationIndex\",\n    value: function getNotificationIndex(archive) {\n      return this.notifications.reduce(function (matchedIndex, currentNotification, currentIndex) {\n        return currentNotification.archive.archiveId === archive.archiveId ? currentIndex : matchedIndex;\n      }, -1);\n    }\n    /**\n     * initializes the archivesIDs and current stream\n     *\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"initLoaders\",\n    value: function initLoaders() {\n      var _this = this;\n\n      this.archiveIds = this.ControllerHelper.request.getArrayLoader({\n        loaderFunction: function loaderFunction() {\n          return _this.LogsStreamsArchivesService.getArchiveIds(_this.serviceName, _this.streamId);\n        }\n      });\n      this.stream = this.ControllerHelper.request.getHashLoader({\n        loaderFunction: function loaderFunction() {\n          return _this.LogsStreamsService.getStream(_this.serviceName, _this.streamId);\n        }\n      });\n    }\n    /**\n     * Updates the list of archive with the latest information of the archive\n     *\n     * @param {any} archiveId\n     * @returns promise which will be resolve with the reloaded archive\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"reloadArchiveDetail\",\n    value: function reloadArchiveDetail(archiveId) {\n      var _this2 = this;\n\n      this.archiveReload = this.ControllerHelper.request.getArrayLoader({\n        loaderFunction: function loaderFunction() {\n          return _this2.LogsStreamsArchivesService.getArchives(_this2.serviceName, _this2.streamId, [archiveId]);\n        }\n      });\n      return this.archiveReload.load().then(function (archives) {\n        var archive = archives[0];\n\n        _this2.archives.data.forEach(function (archiveItem, archiveIndex) {\n          if (archiveItem.archiveId === archive.archiveId) {\n            _this2.archives.data[archiveIndex] = archive;\n          }\n        });\n\n        return archive;\n      });\n    }\n    /**\n     * Removes the notification for an archive if available\n     *\n     * @param {any} archive\n     * @returns Returns the removed notification\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"removeNotification\",\n    value: function removeNotification(archive) {\n      var notificationIndex = this.getNotificationIndex(archive);\n      return this.notifications.splice(notificationIndex, notificationIndex >= 0 ? 1 : 0);\n    }\n    /**\n     * Starts an interval that runs every second, that updates\n     * the remaining unsealing time for all archives being unsealed\n     *\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"startRetrievalDelayUpdate\",\n    value: function startRetrievalDelayUpdate() {\n      var _this3 = this;\n\n      this.retrievalDelayUpdater = this.$interval(function () {\n        return _this3.updateRetrievalDelay();\n      }, 1000);\n    }\n    /**\n     * Stops the interval that updates the remaining unsealing\n     * time for all archives being unsealed\n     *\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"stopRetrievalDelayUpdate\",\n    value: function stopRetrievalDelayUpdate() {\n      this.$interval.cancel(this.retrievalDelayUpdater);\n    }\n    /**\n     * Updates the notification for an archive if available. Else adds the notification\n     *\n     * @param {any} archive\n     * @param {any} notification\n     * @returns Returns the updated/inserted notification\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"updateNotification\",\n    value: function updateNotification(notification) {\n      var notificationIndex = this.getNotificationIndex(notification.archive);\n\n      if (notificationIndex >= 0) {\n        this.notifications[notificationIndex] = notification;\n      } else {\n        this.notifications.push(notification);\n      }\n\n      return this.notifications;\n    }\n    /**\n     * Loops through all archives and reduces the remaining unsealing\n     * time for archives being unsealed. Also sets an archive to available\n     * when the unsealing is complete and issues a notification\n     *\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"updateRetrievalDelay\",\n    value: function updateRetrievalDelay() {\n      var _this4 = this;\n\n      _.clone(this.notifications).forEach(function (notification) {\n        var archive = notification.archive;\n        archive.retrievalDelay = archive.retrievalDelay > 0 ? archive.retrievalDelay -= 1 : archive.retrievalDelay;\n\n        if (archive.retrievalState === _this4.LogsConstants.state.UNSEALING) {\n          if (archive.retrievalDelay === 0) {\n            archive.retrievalState = _this4.LogsConstants.state.UNSEALED;\n\n            _this4.LogsStreamsArchivesService.transformArchive(archive);\n          }\n\n          _this4.updateUnfreezingNotification(archive);\n        }\n      });\n    }\n    /**\n     * Updates the notification for an archive that is being unsealed.\n     * If the archive is not being unsealed, the notification is removed\n     *\n     * @param {any} archive\n     * @returns Returns the updated/removed notification\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"updateUnfreezingNotification\",\n    value: function updateUnfreezingNotification(archive) {\n      return archive.retrievalState === this.LogsConstants.state.UNSEALING ? [this.updateNotification({\n        text: this.$translate.instant('streams_archives_unfreezing', {\n          name: archive.filename,\n          time: moment.utc(archive.retrievalDelay * 1000).format('HH:mm:ss')\n        }),\n        type: 'info',\n        archive: archive\n      })] : this.removeNotification(archive);\n    }\n    /**\n     * Gets the URL for an archive and downloads it\n     *\n     * @param {any} archive\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"download\",\n    value: function download(archive) {\n      var _this5 = this;\n\n      this.updateNotification({\n        text: this.$translate.instant('streams_archives_preparing_download', {\n          filename: archive.filename\n        }),\n        type: 'info',\n        archive: archive\n      });\n      this.ControllerHelper.scrollPageToTop();\n      this.archiveDownload = this.ControllerHelper.request.getHashLoader({\n        loaderFunction: function loaderFunction() {\n          return _this5.LogsStreamsArchivesService.getDownloadUrl(_this5.serviceName, _this5.streamId, archive.archiveId);\n        }\n      });\n      this.archiveDownload.load().then(function (urlInfo) {\n        _this5.removeNotification(archive);\n\n        _this5.ControllerHelper.constructor.downloadUrl(urlInfo.url);\n      });\n    }\n    /**\n     * Loads a number of archives specified by the pageSize, starting from the specified offset\n     * Also issues a notification for archives being unsealed\n     *\n     * @param {any} offset\n     * @param {any} pageSize\n     * @returns promise which will be resolve to the loaded archives data\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"loadArchives\",\n    value: function loadArchives(_ref) {\n      var _this6 = this;\n\n      var offset = _ref.offset,\n          pageSize = _ref.pageSize;\n      this.stopRetrievalDelayUpdate();\n      this.archives = this.ControllerHelper.request.getArrayLoader({\n        loaderFunction: function loaderFunction() {\n          return _this6.LogsStreamsArchivesService.getArchives(_this6.serviceName, _this6.streamId, _this6.archiveIds.data.slice(offset - 1, offset + pageSize - 1));\n        }\n      });\n      return this.archives.load().then(function (archives) {\n        return {\n          data: archives,\n          meta: {\n            totalCount: _this6.archiveIds.data.length\n          }\n        };\n      }).then(this.startRetrievalDelayUpdate()).then(function (archivesData) {\n        archivesData.data.forEach(function (archive) {\n          return _this6.updateUnfreezingNotification(archive);\n        });\n        return archivesData;\n      });\n    }\n    /**\n     * Starts the unsealing process for an archive and issues a notification\n     * with the remaining time after which the archive would be available for download\n     *\n     * @param {any} archive\n     * @memberof LogsStreamsArchivesHomeCtrl\n     */\n\n  }, {\n    key: \"unfreeze\",\n    value: function unfreeze(archive) {\n      var _this7 = this;\n\n      this.updateNotification({\n        text: this.$translate.instant('streams_archives_unfreeze_start', {\n          filename: archive.filename\n        }),\n        type: 'info',\n        archive: archive\n      });\n      this.ControllerHelper.scrollPageToTop();\n      this.LogsStreamsArchivesService.getDownloadUrl(this.serviceName, this.streamId, archive.archiveId).then(function () {\n        return _this7.reloadArchiveDetail(archive.archiveId);\n      }).then(function (updatedArchive) {\n        return _this7.updateUnfreezingNotification(updatedArchive);\n      }).catch(function (err) {\n        _this7.updateNotification({\n          text: _this7.$translate.instant('streams_archives_url_load_error', {\n            filename: archive.filename,\n            message: err\n          }),\n          type: 'error',\n          archive: archive\n        });\n      });\n    }\n  }]);\n\n  return LogsStreamsArchivesCtrl;\n}();\n\nangular.module('managerApp').controller('LogsStreamsArchivesCtrl', LogsStreamsArchivesCtrl);",null]}